package main

// This function returns the best practices for writing Go Code.
// Some aprts are reduced to decrease the token count
func GetBestPractices() string {
	return "# Go Style Best Practices\n\n## About\n\nThis file documents **guidance about how to best apply the Go Style Guide**.\nThis guidance is intended for common situations that arise frequently, but may\nnot apply in every circumstance. Where possible, multiple alternative approaches\nare discussed along with the considerations that go into the decision about when\nand when not to apply them.\n\n## Naming\n\n### Function and method names\n\n#### Avoid repetition\n\nWhen choosing the name for a function or method, consider the context in which\nthe name will be read. Consider the following recommendations to avoid excess\n[repetition](decisions#repetition) at the call site:\n\n*   The following can generally be omitted from function and method names:\n\n    *   The types of the inputs and outputs (when there is no collision)\n    *   The type of a method's receiver\n    *   Whether an input or output is a pointer\n\n    *   For functions, do not\n        [repeat the name of the package](decisions#repetitive-with-package).\n\n    ```go\n    // Bad:\n    package yamlconfig\n\n    func ParseYAMLConfig(input string) (*Config, error)\n\t```\n\n    ```go\n    // Good:\n    package yamlconfig\n    \n    func Parse(input string) (*Config, error)\n\t```\n\n*   For methods, do not repeat the name of the method receiver.\n\n    ```go\n\t// Bad:\n\t\tfunc (c *Config) WriteConfigTo(w io.Writer) (int64, error)\n\t```\n\n    ```go\n\t// Good:\n\t\tfunc (c *Config) WriteTo(w io.Writer) (int64, error)\n\t```\n\n*   Do not repeat the names of variables passed as parameters.\n\n    ```go\n\t// Bad:\n\t\tfunc OverrideFirstWithSecond(dest, source *Config) error\n\t```\n\n    ```go\n\t// Good:\n\t\tfunc Override(dest, source *Config) error\n\t```\n\n*   Do not repeat the names and types of the return values.\n\n    ```go\n\t// Bad:\n\t\tfunc TransformYAMLToJSON(input *Config) *jsonconfig.Config\n\t```\n\n    ```go\n\t// Good:\n\t\tfunc Transform(input *Config) *jsonconfig.Config\n\t```\n\nWhen it is necessary to disambiguate functions of a similar name, it is\nacceptable to include extra information.\n\n```go\n\t// Good:\n\t\tfunc (c *Config) WriteTextTo(w io.Writer) (int64, error)\n\tfunc (c *Config) WriteBinaryTo(w io.Writer) (int64, error)\n\t```\n\n\n\n#### Naming conventions\n\nThere are some other common conventions when choosing names for functions and\nmethods:\n\n*   Functions that return something are given noun-like names.\n\n    ```go\n\t// Good:\n\t\tfunc (c *Config) JobName(key string) (value string, ok bool)\n\t```\n\n    A corollary of this is that function and method names should\n    [avoid the prefix `Get`](decisions#getters).\n\n    ```go\n\t// Bad:\n\t\tfunc (c *Config) GetJobName(key string) (value string, ok bool)\n\t```\n\n*   Functions that do something are given verb-like names.\n\n    ```go\n\t// Good:\n\t\tfunc (c *Config) WriteDetail(w io.Writer) (int64, error)\n\t```\n\n*   Identical functions that differ only by the types involved include the name\n    of the type at the end of the name.\n\n    ```go\n\t// Good:\n\t\tfunc ParseInt(input string) (int, error)\n\tfunc ParseInt64(input string) (int64, error)\n\tfunc AppendInt(buf []byte, value int) []byte\n\tfunc AppendInt64(buf []byte, value int64) []byte\n\t```\n\n    If there is a clear \"primary\" version, the type can be omitted from the name\n    for that version:\n\n    ```go\n\t// Good:\n\t\tfunc (c *Config) Marshal() ([]byte, error)\n\tfunc (c *Config) MarshalText() (string, error)\n\t```\n\n\n\n### Test double packages and types\n\nThere are several disciplines you can apply to [naming] packages and types that\nprovide test helpers and especially [test doubles]. A test double could be a\nstub, fake, mock, or spy.\n\nThese examples mostly use stubs. Update your names accordingly if your code uses\nfakes or another kind of test double.\n\n[naming]: guide#naming\n[test doubles]: https://abseil.io/resources/swe-book/html/ch13.html#basic_concepts\n\nSuppose you have a well-focused package providing production code similar to\nthis:\n\n```go\n\tpackage creditcard\n\n\timport (\n\t\t\"errors\"\n\n\t\"path/to/money\"\n\t)\n\n\t// ErrDeclined indicates that the issuer declines the charge.\n\tvar ErrDeclined = errors.New(\"creditcard: declined\")\n\n\t// Card contains information about a credit card, such as its issuer,\n\t// expiration, and limit.\n\ttype Card struct {\n\t\t// omitted\n\t}\n\n\t// Service allows you to perform operations with credit cards against external\n\t// payment processor vendors like charge, authorize, reimburse, and subscribe.\n\ttype Service struct {\n\t\t// omitted\n\t}\n\n\tfunc (s *Service) Charge(c *Card, amount money.Money) error { /* omitted */ }\n\t```\n\n\n\n#### Creating test helper packages\n\nSuppose you want to create a package that contains test doubles for another.\nWe'll use `package creditcard` (from above) for this example:\n\nOne approach is to introduce a new Go package based on the production one for\ntesting. A safe choice is to append the word `test` to the original package name\n(\"creditcard\" + \"test\"):\n\n```go\n\t// Good:\n\tpackage creditcardtest\n\t```\n\nUnless stated explicitly otherwise, all examples in the sections below are in\n`package creditcardtest`.\n\n\n\n#### Simple case\n\nYou want to add a set of test doubles for `Service`. Because `Card` is\neffectively a dumb data type, similar to a Protocol Buffer message, it needs no\nspecial treatment in tests, so no double is required. If you anticipate only\ntest doubles for one type (like `Service`), you can take a concise approach to\nnaming the doubles:\n\n```go\n\t// Good:\n\timport (\n\t\t\"path/to/creditcard\"\n\t\"path/to/money\"\n\t)\n\n\t// Stub stubs creditcard.Service and provides no behavior of its own.\n\ttype Stub struct{}\n\n\tfunc (Stub) Charge(*creditcard.Card, money.Money) error { return nil }\n\t```\n\nThis is strictly preferable to a naming choice like `StubService` or the very\npoor `StubCreditCardService`, because the base package name and its domain types\nimply what `creditcardtest.Stub` is.\n\nFinally, if the package is built with Bazel, make sure the new `go_library` rule\nfor the package is marked as `testonly`:\n\n```build\n\t# Good:\n\tgo_library(\n\t\tname = \"creditcardtest\",\n\t\tsrcs = [\"creditcardtest.go\"],\ndeps = [\n\":creditcard\",\n\":money\",\n],\ntestonly = True,\n)\n```\n\nThe approach above is conventional and will be reasonably well understood by\nother engineers.\n\n\n#### Multiple test double behaviors\n\nWhen one kind of stub is not enough (for example, you also need one that always\nfails), we recommend naming the stubs according to the behavior they emulate.\nHere we rename `Stub` to `AlwaysCharges` and introduce a new stub called\n`AlwaysDeclines`:\n\n```go\n// Good:\n// AlwaysCharges stubs creditcard.Service and simulates success.\ntype AlwaysCharges struct{}\n\nfunc (AlwaysCharges) Charge(*creditcard.Card, money.Money) error { return nil }\n\n// AlwaysDeclines stubs creditcard.Service and simulates declined charges.\ntype AlwaysDeclines struct{}\n\nfunc (AlwaysDeclines) Charge(*creditcard.Card, money.Money) error {\n\treturn creditcard.ErrDeclined\n}\n```\n\n\n\n#### Multiple doubles for multiple types\n\nBut now suppose that `package creditcard` contains multiple types worth creating\ndoubles for, as seen below with `Service` and `StoredValue`:\n\n```go\npackage creditcard\n\ntype Service struct {\n\t// omitted\n}\n\ntype Card struct {\n\t// omitted\n}\n\n// StoredValue manages customer credit balances.  This applies when returned\n// merchandise is credited to a customer's local account instead of processed\n// by the credit issuer.  For this reason, it is implemented as a separate\n// service.\ntype StoredValue struct {\n\t// omitted\n}\n\nfunc (s *StoredValue) Credit(c *Card, amount money.Money) error { /* omitted */ }\n```\n\nIn this case, more explicit test double naming is sensible:\n\n```go\n// Good:\ntype StubService struct{}\n\nfunc (StubService) Charge(*creditcard.Card, money.Money) error { return nil }\n\ntype StubStoredValue struct{}\n\nfunc (StubStoredValue) Credit(*creditcard.Card, money.Money) error { return nil }\n```\n\n\n\n#### Local variables in tests\n\nWhen variables in your tests refer to doubles, choose a name that most clearly\ndifferentiates the double from other production types based on context. Consider\nsome production code you want to test:\n\n```go\npackage payment\n\nimport (\n\"path/to/creditcard\"\n\"path/to/money\"\n)\n\ntype CreditCard interface {\n\tCharge(*creditcard.Card, money.Money) error\n}\n\ntype Processor struct {\n\tCC CreditCard\n}\n\nvar ErrBadInstrument = errors.New(\"payment: instrument is invalid or expired\")\n\nfunc (p *Processor) Process(c *creditcard.Card, amount money.Money) error {\n\tif c.Expired() {\n\t\treturn ErrBadInstrument\n\t}\n\treturn p.CC.Charge(c, amount)\n}\n```\n\nIn the tests, a test double called a \"spy\" for `CreditCard` is juxtaposed\nagainst production types, so prefixing the name may improve clarity.\n\n```go\n// Good:\npackage payment\n\nimport \"path/to/creditcardtest\"\n\nfunc TestProcessor(t *testing.T) {\n\tvar spyCC creditcardtest.Spy\n\tproc := &Processor{CC: spyCC}\n\n\t// declarations omitted: card and amount\n\tif err := proc.Process(card, amount); err != nil {\n\t\tt.Errorf(\"proc.Process(card, amount) = %v, want nil\", err)\n\t}\n\n\tcharges := []creditcardtest.Charge{\n\t\t{Card: card, Amount: amount},\n\t}\n\n\tif got, want := spyCC.Charges, charges; !cmp.Equal(got, want) {\n\t\tt.Errorf(\"spyCC.Charges = %v, want %v\", got, want)\n\t}\n}\n```\n\nThis is clearer than when the name is not prefixed.\n\n```go\n// Bad:\npackage payment\n\nimport \"path/to/creditcardtest\"\n\nfunc TestProcessor(t *testing.T) {\n\tvar cc creditcardtest.Spy\n\n\tproc := &Processor{CC: cc}\n\n\t// declarations omitted: card and amount\n\tif err := proc.Process(card, amount); err != nil {\n\t\tt.Errorf(\"proc.Process(card, amount) = %v, want nil\", err)\n\t}\n\n\tcharges := []creditcardtest.Charge{\n\t\t{Card: card, Amount: amount},\n\t}\n\n\tif got, want := cc.Charges, charges; !cmp.Equal(got, want) {\n\t\tt.Errorf(\"cc.Charges = %v, want %v\", got, want)\n\t}\n}\n```\n\n\n\n### Shadowing\n\n**Note:** This explanation uses two informal terms, *stomping* and *shadowing*.\nThey are not official concepts in the Go language spec.\n\nLike many programming languages, Go has mutable variables: assigning to a\nvariable changes its value.\n\n```go\n// Good:\nfunc abs(i int) int {\n\tif i < 0 {\n\t\ti *= -1\n\t}\n\treturn i\n}\n```\n\nWhen using [short variable declarations] with the `:=` operator, in some cases a\nnew variable is not created. We can call this *stomping*. It's OK to do this\nwhen the original value is no longer needed.\n\n```go\n// Good:\n// innerHandler is a helper for some request handler, which itself issues\n// requests to other backends.\nfunc (s *Server) innerHandler(ctx context.Context, req *pb.MyRequest) *pb.MyResponse {\n\t// Unconditionally cap the deadline for this part of request handling.\n\tctx, cancel := context.WithTimeout(ctx, 3*time.Second)\n\tdefer cancel()\n\tctxlog.Info(ctx, \"Capped deadline in inner request\")\n\n\t// Code here no longer has access to the original context.\n\t// This is good style if when first writing this, you anticipate\n\t// that even as the code grows, no operation legitimately should\n\t// use the (possibly unbounded) original context that the caller provided.\n\n\t// ...\n}\n```\n\nBe careful using short variable declarations in a new scope, though: that\nintroduces a new variable. We can call this *shadowing* the original variable.\nCode after the end of the block refers to the original. Here is a buggy attempt\nto shorten the deadline conditionally:\n\n```go\n// Bad:\nfunc (s *Server) innerHandler(ctx context.Context, req *pb.MyRequest) *pb.MyResponse {\n\t// Attempt to conditionally cap the deadline.\n\tif *shortenDeadlines {\n\t\tctx, cancel := context.WithTimeout(ctx, 3*time.Second)\n\t\tdefer cancel()\n\t\tctxlog.Info(ctx, \"Capped deadline in inner request\")\n\t}\n\n\t// BUG: \"ctx\" here again means the context that the caller provided.\n\t// The above buggy code compiled because both ctx and cancel\n\t// were used inside the if statement.\n\n\t// ...\n}\n```\n\nA correct version of the code might be:\n\n```go\n// Good:\nfunc (s *Server) innerHandler(ctx context.Context, req *pb.MyRequest) *pb.MyResponse {\n\tif *shortenDeadlines {\n\t\tvar cancel func()\n\t\t// Note the use of simple assignment, = and not :=.\n\t\tctx, cancel = context.WithTimeout(ctx, 3*time.Second)\n\t\tdefer cancel()\n\t\tctxlog.Info(ctx, \"Capped deadline in inner request\")\n\t}\n\t// ...\n}\n```\n\nIn the case we called stomping, because there's no new variable, the type being\nassigned must match that of the original variable. With shadowing, an entirely\nnew entity is introduced so it can have a different type. Intentional shadowing\ncan be a useful practice, but you can always use a new name if it improves\n[clarity](guide#clarity).\n\nIt is not a good idea to use variables with the same name as standard packages\nother than very small scopes, because that renders free functions and values\nfrom that package inaccessible. Conversely, when picking a name for your\npackage, avoid names that are likely to require\n[import renaming](decisions#import-renaming) or cause shadowing of otherwise\ngood variable names at the client side.\n\n```go\n// Bad:\nfunc LongFunction() {\n\turl := \"https://example.com/\"\n\t// Oops, now we can't use net/url in code below.\n}\n```\n\n[short variable declarations]: https://go.dev/ref/spec#Short_variable_declarations\n\n\n\n### Util packages\n\nGo packages have a name specified on the `package` declaration, separate from\nthe import path. The package name matters more for readability than the path.\n\nGo package names should be\n[related to what the package provides](decisions#package-names). Naming a\npackage just `util`, `helper`, `common` or similar is usually a poor choice (it\ncan be used as *part* of the name though). Uninformative names make the code\nharder to read, and if used too broadly they are liable to cause needless\n[import conflicts](decisions#import-renaming).\n\nInstead, consider what the callsite will look like.\n\n```go\n// Good:\ndb := spannertest.NewDatabaseFromFile(...)\n\n_, err := f.Seek(0, io.SeekStart)\n\nb := elliptic.Marshal(curve, x, y)\n```\n\nYou can tell roughly what each of these do even without knowing the imports list\n(`cloud.google.com/go/spanner/spannertest`, `io`, and `crypto/elliptic`). With\nless focused names, these might read:\n\n```go\n// Bad:\ndb := test.NewDatabaseFromFile(...)\n\n_, err := f.Seek(0, common.SeekStart)\n\nb := helper.Marshal(curve, x, y)\n```\n\n\n\n## Package size\n\nIf you're asking yourself how big your Go packages should be and whether to\nplace related types in the same package or split them into different ones, a\ngood place to start is the [Go blog post about package names][blog-pkg-names].\nDespite the post title, it's not solely about naming. It contains some helpful\nhints and cites several useful articles and talks.\n\nHere are some other considerations and notes.\n\nUsers see [godoc] for the package in one page, and any methods exported by types\nsupplied by the package are grouped by their type. Godoc also group constructors\nalong with the types they return. If *client code* is likely to need two values\nof different type to interact with each other, it may be convenient for the user\nto have them in the same package.\n\nCode within a package can access unexported identifiers in the package. If you\nhave a few related types whose *implementation* is tightly coupled, placing them\nin the same package lets you achieve this coupling without polluting the public\nAPI with these details. A good test for this coupling is to imagine a\nhypothetical user of two packages, where the packages cover closely related\ntopics: if the user must import both packages in order to use either in any\nmeaningful way, combining them together is usually the right thing to do. The\nstandard library generally demonstrates this kind of scoping and layering well.\n\nAll of that being said, putting your entire project in a single package would\nlikely make that package too large. When something is conceptually distinct,\ngiving it its own small package can make it easier to use. The short name of the\npackage as known to clients together with the exported type name work together\nto make a meaningful identifier: e.g. `bytes.Buffer`, `ring.New`. The\n[blog post][blog-pkg-names] has more examples.\n\nGo style is flexible about file size, because maintainers can move code within a\npackage from one file to another without affecting callers. But as a general\nguideline: it is usually not a good idea to have a single file with many\nthousands of lines in it, or having many tiny files. There is no \"one type, one\nfile\" convention as in some other languages. As a rule of thumb, files should be\nfocused enough that a maintainer can tell which file contains something, and the\nfiles should be small enough that it will be easy to find once there. The\nstandard library often splits large packages to several source files, grouping\nrelated code by file. The source for [package `bytes`] is a good example.\nPackages with long package documentation may choose to dedicate one file called\n`doc.go` that has the [package documentation](decisions#package-comments), a\npackage declaration, and nothing else, but this is not required.\n\nWithin the Google codebase and in projects using Bazel, directory layout for Go\ncode is different than it is in open source Go projects: you can have multiple\n`go_library` targets in a single directory. A good reason to give each package\nits own directory is if you expect to open source your project in the future.\n\n\n## Imports\n\n\n\n### Protos and stubs\n\nProto library imports are treated differently than standard Go imports due to\ntheir cross-language nature. The convention for renamed proto imports are based\non the rule that generated the package:\n\n*   The `pb` suffix is generally used for `go_proto_library` rules.\n*   The `grpc` suffix is generally used for `go_grpc_library` rules.\n\nGenerally, a short one- or two-letter prefix is used:\n\n```go\n// Good:\nimport (\nfspb \"path/to/package/foo_service_go_proto\"\nfsgrpc \"path/to/package/foo_service_go_grpc\"\n)\n```\n\nIf there is only a single proto used by a package or the package is tied closely\nto that proto, the prefix can be omitted:\n\nimport ( pb \"path/to/package/foo_service_go_proto\" grpc\n\"path/to/package/foo_service_go_grpc\" )\n\nIf the symbols in the proto are generic or are not very self-descriptive, or if\nshortening the package name with an acronym is unclear, a short word can suffice\nas the prefix:\n\n```go\n// Good:\nimport (\nmapspb \"path/to/package/maps_go_proto\"\n)\n```\n\nIn this case `mapspb.Address` might be clearer than `mpb.Address` if the code in\nquestion is not already clearly related to maps.\n\n\n\n### Import ordering\n\nImports are typically grouped into the following two (or more) blocks, in order:\n\n1.  Standard library imports (e.g., `\"fmt\"`)\n1.  imports (e.g., \"/path/to/somelib\")\n1.  (optional) Protobuf imports (e.g., `fpb \"path/to/foo_go_proto\"`)\n1.  (optional) Side-effect imports (e.g., `_ \"path/to/package\"`)\n\nIf a file does not have a group for one of the optional categories above, the\nrelevant imports are included in the project import group.\n\nAny import grouping that is clear and easy to understand is generally fine. For\nexample, a team may choose to group gRPC imports separately from protobuf\nimports.\n\n> **Note:** For code maintaining only the two mandatory groups (one group for\n> the standard library and one for all other imports), the `goimports` tool\n> produces output consistent with this guidance.\n>\n> However, `goimports` has no knowledge of groups beyond the mandatory ones; the\n> optional groups are prone to invalidation by the tool. When optional groups\n> are used, attention on the part of both authors and reviewers is required to\n> ensure that groupings remain compliant.\n>\n> Either approach is fine, but do not leave the imports section in an\n> inconsistent, partially grouped state.\n\n\n\n## Error handling\n\nIn Go, [errors are values]; they are created by code and consumed by code.\nErrors can be:\n\n*   Converted into diagnostic information for display to humans\n*   Used by the maintainer\n*   Interpreted by an end user\n\nError messages also show up across a variety of different surfaces including log\nmessages, error dumps, and rendered UIs.\n\nCode that processes (produces or consumes) errors should do so deliberately. It\ncan be tempting to ignore or blindly propagate an error return value. However,\nit is always worth considering whether the current function in the call frame is\npositioned to handle the error most effectively. This is a large topic and it is\nhard to give categorical advice. Use your judgment, but keep the following\nconsiderations in mind:\n\n*   When creating an error value, decide whether to give it any\n    [structure](#error-structure).\n*   When handling an error, consider [adding information](#error-extra-info)\n    that you have but that the caller and/or callee might not.\n\nWhile it is usually not appropriate to ignore an error, a reasonable exception\nto this is when orchestrating related operations, where often only the first\nerror is useful. Package [`errgroup`] provides a convenient abstraction for a\ngroup of operations that can all fail or be canceled as a group.\n\n[errors are values]: https://go.dev/blog/errors-are-values\n[`errgroup`]: https://pkg.go.dev/golang.org/x/sync/errgroup\n\n\n\n\n### Error structure\n\nIf callers need to interrogate the error (e.g., distinguish different error\nconditions), give the error value structure so that this can be done\nprogrammatically rather than having the caller perform string matching. This\nadvice applies to production code as well as to tests that care about different\nerror conditions.\n\nThe simplest structured errors are unparameterized global values.\n\n```go\ntype Animal string\n\nvar (\n\t// ErrDuplicate occurs if this animal has already been seen.\n\tErrDuplicate = errors.New(\"duplicate\")\n\n\t// ErrMarsupial occurs because we're allergic to marsupials outside Australia.\n\t// Sorry.\n\tErrMarsupial = errors.New(\"marsupials are not supported\")\n)\n\nfunc process(animal Animal) error {\n\tswitch {\n\tcase seen[animal]:\n\t\treturn ErrDuplicate\n\tcase marsupial(animal):\n\t\treturn ErrMarsupial\n\t}\n\tseen[animal] = true\n\t// ...\n\treturn nil\n}\n```\n\nThe caller can simply compare the returned error value of the function with one\nof the known error values:\n\n```go\n// Good:\nfunc handlePet(...) {\n\tswitch err := process(an); err {\n\tcase ErrDuplicate:\n\t\treturn fmt.Errorf(\"feed %q: %v\", an, err)\n\tcase ErrMarsupial:\n\t\t// Try to recover with a friend instead.\n\t\talternate = an.BackupAnimal()\n\t\treturn handlePet(..., alternate, ...)\n\t}\n}\n```\n\nThe above uses sentinel values, where the error must be equal (in the sense of\n`==`) to the expected value. That is perfectly adequate in many cases. If\n`process` returns wrapped errors (discussed below), you can use [`errors.Is`].\n\n```go\n// Good:\nfunc handlePet(...) {\n\tswitch err := process(an); {\n\tcase errors.Is(err, ErrDuplicate):\n\t\treturn fmt.Errorf(\"feed %q: %v\", an, err)\n\tcase errors.Is(err, ErrMarsupial):\n\t\t// ...\n\t}\n}\n```\n\nDo not attempt to distinguish errors based on their string form. (See\n[Go Tip #13: Designing Errors for Checking](https://google.github.io/styleguide/go/index.html#gotip)\nfor more.)\n\n```go\n// Bad:\nfunc handlePet(...) {\n\terr := process(an)\n\tif regexp.MatchString(`duplicate`, err.Error()) {...}\n\tif regexp.MatchString(`marsupial`, err.Error()) {...}\n}\n```\n\nIf there is extra information in the error that the caller needs\nprogrammatically, it should ideally be presented structurally. For example, the\n[`os.PathError`] type is documented to place the pathname of the failing\noperation in a struct field which the caller can easily access.\n\nOther error structures can be used as appropriate, for example a project struct\ncontaining an error code and detail string. [Package `status`][status] is a\ncommon encapsulation; if you choose this approach (which you are not obligated\nto do), use [canonical codes]. See\n[Go Tip #89: When to Use Canonical Status Codes as Errors](https://google.github.io/styleguide/go/index.html#gotip)\nto know if using status codes is the right choice.\n\n[`os.PathError`]: https://pkg.go.dev/os#PathError\n[`errors.Is`]: https://pkg.go.dev/errors#Is\n[`errors.As`]: https://pkg.go.dev/errors#As\n[`package cmp`]: https://pkg.go.dev/github.com/google/go-cmp/cmp\n[status]: https://pkg.go.dev/google.golang.org/grpc/status\n[canonical codes]: https://pkg.go.dev/google.golang.org/grpc/codes\n\n\n\n### Adding information to errors\n\nAny function returning an error should strive to make the error value useful.\nOften, the function is in the middle of a callchain and is merely propagating an\nerror from some other function that it called (maybe even from another package).\nHere there is an opportunity to annotate the error with extra information, but\nthe programmer should ensure there's sufficient information in the error without\nadding duplicate or irrelevant detail. If you're unsure, try triggering the\nerror condition during development: that's a good way to assess what the\nobservers of the error (either humans or code) will end up with.\n\nConvention and good documentation help. For example, the standard package `os`\nadvertises that its errors contain path information when it is available. This\nis a useful style, because callers getting back an error don't need to annotate\nit with information that they had already provided the failing function.\n\n```go\n// Good:\nif err := os.Open(\"settings.txt\"); err != nil {\nreturn err\n}\n\n// Output:\n//\n// open settings.txt: no such file or directory\n```\n\nIf there is something interesting to say about the *meaning* of the error, of\ncourse it can be added. Just consider which level of the callchain is best\npositioned to understand this meaning.\n\n```go\n// Good:\nif err := os.Open(\"settings.txt\"); err != nil {\n// We convey the significance of this error to us. Note that the current\n// function might perform more than one file operation that can fail, so\n// these annotations can also serve to disambiguate to the caller what went\n// wrong.\nreturn fmt.Errorf(\"launch codes unavailable: %v\", err)\n}\n\n// Output:\n//\n// launch codes unavailable: open settings.txt: no such file or directory\n```\n\nContrast with the redundant information here:\n\n```go\n// Bad:\nif err := os.Open(\"settings.txt\"); err != nil {\nreturn fmt.Errorf(\"could not open settings.txt: %w\", err)\n}\n\n// Output:\n//\n// could not open settings.txt: open settings.txt: no such file or directory\n```\n\nWhen adding information to a propagated error, you can either wrap the error or\npresent a fresh error. Wrapping the error with the `%w` verb in `fmt.Errorf`\nallows callers to access data from the original error. This can be very useful\nat times, but in other cases these details are misleading or uninteresting to\nthe caller. See the\n[blog post on error wrapping](https://blog.golang.org/go1.13-errors) for more\ninformation. Wrapping errors also expands the API surface of your package in a\nnon-obvious way, and this can cause breakages if you change the implementation\ndetails of your package.\n\nIt is best to avoid using `%w` unless you also document (and have tests that\nvalidate) the underlying errors that you expose. If you do not expect your\ncaller to call `errors.Unwrap`, `errors.Is` and so on, don't bother with `%w`.\n\nThe same concept applies to [structured errors](#error-structure) like\n[`*status.Status`][status] (see [canonical codes]). For example, if your server\nsends malformed requests to a backend and receives an `InvalidArgument` code,\nthis code should *not* be propagated to the client, assuming that the client has\ndone nothing wrong. Instead, return an `Internal` canonical code to the client.\n\nHowever, annotating errors helps automated logging systems preserve the status\npayload of an error. For example, annotating the error is appropriate in an\ninternal function:\n\n```go\n// Good:\nfunc (s *Server) internalFunction(ctx context.Context) error {\n\t// ...\n\tif err != nil {\n\t\treturn fmt.Errorf(\"couldn't find remote file: %w\", err)\n\t}\n}\n```\n\nCode directly at system boundaries (typically RPC, IPC, storage, and similar)\nshould report errors using the canonical error space. It is the responsibility\nof code here to handle domain-specific errors and represent them canonically.\nFor example:\n\n```go\n// Bad:\nfunc (*FortuneTeller) SuggestFortune(context.Context, *pb.SuggestionRequest) (*pb.SuggestionResponse, error) {\n\t// ...\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't find remote file: %w\", err)\n\t}\n}\n```\n\n```go\n// Good:\nimport (\n\"google.golang.org/grpc/codes\"\n\"google.golang.org/grpc/status\"\n)\nfunc (*FortuneTeller) SuggestFortune(context.Context, *pb.SuggestionRequest) (*pb.SuggestionResponse, error) {\n\t// ...\n\tif err != nil {\n\t\t// Or use fmt.Errorf with the %w verb if deliberately wrapping an\n\t\t// error which the caller is meant to unwrap.\n\t\treturn nil, status.Errorf(codes.Internal, \"couldn't find fortune database\", status.ErrInternal)\n\t}\n}\n```\n\n### Placement of %w in errors\n\nPrefer to place `%w` at the end of an error string.\n\nErrors can be wrapped with\n[the `%w` verb](https://blog.golang.org/go1.13-errors), or by placing them in a\n[structured error](https://google.github.io/styleguide/go/index.html#gotip) that\nimplements `Unwrap() error` (ex:\n[`fs.PathError`](https://pkg.go.dev/io/fs#PathError)).\n\nWrapped errors form error chains: each new layer of wrapping adds a new entry to\nthe front of the error chain. The error chain can be traversed with the\n`Unwrap() error` method. For example:\n\n```go\nerr1 := fmt.Errorf(\"err1\")\nerr2 := fmt.Errorf(\"err2: %w\", err1)\nerr3 := fmt.Errorf(\"err3: %w\", err2)\n```\n\nThis forms an error chain of the form,\n\n```mermaid\nflowchart LR\nerr3 == err3 wraps err2 ==> err2;\nerr2 == err2 wraps err1 ==> err1;\n```\n\nRegardless of where the `%w` verb is placed, the error returned always\nrepresents the front of the error chain, and the `%w` is the next child.\nSimilarly, `Unwrap() error` always traverses the error chain from newest to\noldest error.\n\nPlacement of the `%w` verb does, however, affect whether the error chain is\nprinted newest to oldest, oldest to newest, or neither:\n\n```go\n// Good:\nerr1 := fmt.Errorf(\"err1\")\nerr2 := fmt.Errorf(\"err2: %w\", err1)\nerr3 := fmt.Errorf(\"err3: %w\", err2)\nfmt.Println(err3) // err3: err2: err1\n// err3 is a newest-to-oldest error chain, that prints newest-to-oldest.\n```\n\n```go\n// Bad:\nerr1 := fmt.Errorf(\"err1\")\nerr2 := fmt.Errorf(\"%w: err2\", err1)\nerr3 := fmt.Errorf(\"%w: err3\", err2)\nfmt.Println(err3) // err1: err2: err3\n// err3 is a newest-to-oldest error chain, that prints oldest-to-newest.\n```\n\n```go\n// Bad:\nerr1 := fmt.Errorf(\"err1\")\nerr2 := fmt.Errorf(\"err2-1 %w err2-2\", err1)\nerr3 := fmt.Errorf(\"err3-1 %w err3-2\", err2)\nfmt.Println(err3) // err3-1 err2-1 err1 err2-2 err3-2\n// err3 is a newest-to-oldest error chain, that neither prints newest-to-oldest\n// nor oldest-to-newest.\n```\n\nTherefore, in order for error text to mirror error chain structure, prefer\nplacing the `%w` verb at the end with the form `[...]: %w`.\n\n\n\n### Logging errors\n\nFunctions sometimes need to tell an external system about an error without\npropagating it to their callers. Logging is an obvious choice here; but be\nconscious of what and how you log errors.\n\n*   Like [good test failure messages], log messages should clearly express what\n    went wrong and help the maintainer by including relevant information to\n    diagnose the problem.\n\n*   Avoid duplication. If you return an error, it's usually better not to log it\n    yourself but rather let the caller handle it. The caller can choose to log\n    the error, or perhaps rate-limit logging using [`rate.Sometimes`]. Other\n    options include attempting recovery or even [stopping the program]. In any\n    case, giving the caller control helps avoid logspam.\n\n    The downside to this approach, however, is that any logging is written using\n    the caller's line coordinates.\n\n*   Be careful with [PII]. Many log sinks are not appropriate destinations for\n    sensitive end-user information.\n\n*   Use `log.Error` sparingly. ERROR level logging causes a flush and is more\n    expensive than lower logging levels. This can have serious performance\n    impact on your code. When deciding between error and warning levels,\n    consider the best practice that messages at the error level should be\n    actionable rather than \"more serious\" than a warning.\n\n*   Inside Google, we have monitoring systems that can be set up for more\n    effective alerting than writing to a log file and hoping someone notices it.\n    This is similar but not identical to the standard library\n    [package `expvar`].\n\n[good test failure messages]: https://google.github.io/styleguide/go/decisions#useful-test-failures\n[stopping the program]: #checks-and-panics\n[`rate.Sometimes`]: https://pkg.go.dev/golang.org/x/time/rate#Sometimes\n[PII]: https://en.wikipedia.org/wiki/Personal_data\n[package `expvar`]: https://pkg.go.dev/expvar\n\n\n\n#### Custom verbosity levels\n\nUse verbose logging ([`log.V`]) to your advantage. Verbose logging can be useful\nfor development and tracing. Establishing a convention around verbosity levels\ncan be helpful. For example:\n\n*   Write a small amount of extra information at `V(1)`\n*   Trace more information in `V(2)`\n*   Dump large internal states in `V(3)`\n\nTo minimize the cost of verbose logging, you should ensure not to accidentally\ncall expensive functions even when `log.V` is turned off. `log.V` offers two\nAPIs. The more convenient one carries the risk of this accidental expense. When\nin doubt, use the slightly more verbose style.\n\n```go\n// Good:\nfor _, sql := range queries {\nlog.V(1).Infof(\"Handling %v\", sql)\nif log.V(2) {\nlog.Infof(\"Handling %v\", sql.Explain())\n}\nsql.Run(...)\n}\n```\n\n```go\n// Bad:\n// sql.Explain called even when this log is not printed.\nlog.V(2).Infof(\"Handling %v\", sql.Explain())\n```\n\n[`log.V`]: https://pkg.go.dev/github.com/golang/glog#V\n\n\n\n### Program initialization\n\nProgram initialization errors (such as bad flags and configuration) should be\npropagated upward to `main`, which should call `log.Exit` with an error that\nexplains how to fix the error. In these cases, `log.Fatal` should not generally\nbe used, because a stack trace that points at the check is not likely to be as\nuseful as a human-generated, actionable message.\n\n\n\n### Program checks and panics\n\nAs stated in the [decision against panics], standard error handling should be\nstructured around error return values. Libraries should prefer returning an\nerror to the caller rather than aborting the program, especially for transient\nerrors.\n\nIt is occasionally necessary to perform consistency checks on an invariant and\nterminate the program if it is violated. In general, this is only done when a\nfailure of the invariant check means that the internal state has become\nunrecoverable. The most reliable way to do this in the Google codebase is to\ncall `log.Fatal`. Using `panic` in these cases is not reliable, because it is\npossible for deferred functions to deadlock or further corrupt internal or\nexternal state.\n\nSimilarly, resist the temptation to recover panics to avoid crashes, as doing so\ncan result in propagating a corrupted state. The further you are from the panic,\nthe less you know about the state of the program, which could be holding locks\nor other resources. The program can then develop other unexpected failure modes\nthat can make the problem even more difficult to diagnose. Instead of trying to\nhandle unexpected panics in code, use monitoring tools to surface unexpected\nfailures and fix related bugs with a high priority.\n\n**Note:** The standard [`net/http` server] violates this advice and recovers\npanics from request handlers. Consensus among experienced Go engineers is that\nthis was a historical mistake. If you sample server logs from application\nservers in other languages, it is common to find large stacktraces that are left\nunhandled. Avoid this pitfall in your servers.\n\n[decision against panics]: https://google.github.io/styleguide/go/decisions#dont-panic\n[`net/http` server]: https://pkg.go.dev/net/http#Server\n\n\n\n### When to panic\n\nThe standard library panics on API misuse. For example, [`reflect`] issues a\npanic in many cases where a value is accessed in a way that suggests it was\nmisinterpreted. This is analogous to the panics on core language bugs such as\naccessing an element of a slice that is out of bounds. Code review and tests\nshould discover such bugs, which are not expected to appear in production code.\nThese panics act as invariant checks that do not depend on a library, as the\nstandard library does not have access to the [levelled `log`] package that the\nGoogle codebase uses.\n\n[`reflect`]: https://pkg.go.dev/reflect\n[levelled `log`]: decisions#logging\n\nAnother case in which panics can be useful, though uncommon, is as an internal\nimplementation detail of a package which always has a matching recover in the\ncallchain. Parsers and similar deeply nested, tightly coupled internal function\ngroups can benefit from this design, where plumbing error returns adds\ncomplexity without value. The key attribute of this design is that these panics\nare never allowed to escape across package boundaries and do not form part of\nthe package's API. This is typically accomplished with a top-level deferred\nrecover that translates a propagating panic into a returned error at the public\nAPI surfaces.\n\nPanic is also used when the compiler cannot identify unreachable code, for\nexample when using a function like `log.Fatal` that will not return:\n\n```go\n// Good:\nfunc answer(i int) string {\n\tswitch i {\n\tcase 42:\n\t\treturn \"yup\"\n\tcase 54:\n\t\treturn \"base 13, huh\"\n\tdefault:\n\t\tlog.Fatalf(\"Sorry, %d is not the answer.\", i)\n\t\tpanic(\"unreachable\")\n\t}\n}\n```\n\n[Do not call `log` functions before flags have been parsed.](https://pkg.go.dev/github.com/golang/glog#pkg-overview)\nIf you must die in a package initialization function (an `init` or a\n[\"must\" function](decisions#must-functions)), a panic is acceptable in place of\nthe fatal logging call.\n\n\n\n## Documentation\n\n\n\n### Conventions\n\nThis section augments the decisions document's [commentary] section.\n\nGo code that is documented in familiar style is easier to read and less likely\nto be misused than something misdocumented or not documented at all. Runnable\n[examples] show up in Godoc and Code Search and are an excellent way of\nexplaining how to use your code.\n\n[examples]: decisions#examples\n\n\n\n#### Parameters and configuration\n\nNot every parameter must be enumerated in the documentation. This applies to:\n\n*   function and method parameters\n*   struct fields\n*   APIs for options\n\nDocument the error-prone or non-obvious fields and parameters by saying why they\nare interesting.\n\nIn the following snippet, the highlighted commentary adds little useful\ninformation to the reader:\n\n```go\n// Bad:\n// Sprintf formats according to a format specifier and returns the resulting\n// string.\n//\n// format is the format, and data is the interpolation data.\nfunc Sprintf(format string, data ...any) string\n```\n\nHowever, this snippet demonstrates a code scenario similar to the previous where\nthe commentary instead states something non-obvious or materially helpful to the\nreader:\n\n```go\n// Good:\n// Sprintf formats according to a format specifier and returns the resulting\n// string.\n//\n// The provided data is used to interpolate the format string. If the data does\n// not match the expected format verbs or the amount of data does not satisfy\n// the format specification, the function will inline warnings about formatting\n// errors into the output string as described by the Format errors section\n// above.\nfunc Sprintf(format string, data ...any) string\n```\n\nConsider your likely audience in choosing what to document and at what depth.\nMaintainers, newcomers to the team, external users, and even yourself six months\nin the future may appreciate slightly different information from what is on your\nmind when you first come to write your docs.\n\n\n#### Contexts\n\nIt is implied that the cancellation of a context argument interrupts the\nfunction it is provided to. If the function can return an error, conventionally\nit is `ctx.Err()`.\n\nThis fact does not need to be restated:\n\n```go\n// Bad:\n// Run executes the worker's run loop.\n//\n// The method will process work until the context is cancelled and accordingly\n// returns an error.\nfunc (Worker) Run(ctx context.Context) error\n```\n\nBecause that is implied, the following is better:\n\n```go\n// Good:\n// Run executes the worker's run loop.\nfunc (Worker) Run(ctx context.Context) error\n```\n\nWhere context behavior is different or non-obvious, it should be expressly\ndocumented if any of the following are true.\n\n*   The function returns an error other than `ctx.Err()` when the context is\n    cancelled:\n\n    ```go\n// Good:\n// Run executes the worker's run loop.\n//\n// If the context is cancelled, Run returns a nil error.\nfunc (Worker) Run(ctx context.Context) error\n```\n\n*   The function has other mechanisms that may interrupt it or affect lifetime:\n\n    ```go\n// Good:\n// Run executes the worker's run loop.\n//\n// Run processes work until the context is cancelled or Stop is called.\n// Context cancellation is handled asynchronously internally: run may return\n// before all work has stopped. The Stop method is synchronous and waits\n// until all operations from the run loop finish. Use Stop for graceful\n// shutdown.\nfunc (Worker) Run(ctx context.Context) error\n\nfunc (Worker) Stop()\n```\n\n*   The function has special expectations about context lifetime, lineage, or\n    attached values:\n\n    ```go\n// Good:\n// NewReceiver starts receiving messages sent to the specified queue.\n// The context should not have a deadline.\nfunc NewReceiver(ctx context.Context) *Receiver\n\n// Principal returns a human-readable name of the party who made the call.\n// The context must have a value attached to it from security.NewContext.\nfunc Principal(ctx context.Context) (name string, ok bool)\n```\n\n    **Warning:** Avoid designing APIs that make such demands (like contexts not\n    having deadlines) from their callers. The above is only an example of how to\n    document this if it cannot be avoided, not an endorsement of the pattern.\n\n\n\n#### Concurrency\n\nGo users assume that conceptually read-only operations are safe for concurrent\nuse and do not require extra synchronization.\n\nThe extra remark about concurrency can safely be removed in this Godoc:\n\n```go\n// Len returns the number of bytes of the unread portion of the buffer;\n// b.Len() == len(b.Bytes()).\n//\n// It is safe to be called concurrently by multiple goroutines.\nfunc (*Buffer) Len() int\n```\n\nMutating operations, however, are not assumed to be safe for concurrent use and\nrequire the user to consider synchronization.\n\nSimilarly, the extra remark about concurrency can safely be removed here:\n\n```go\n// Grow grows the buffer's capacity.\n//\n// It is not safe to be called concurrently by multiple goroutines.\nfunc (*Buffer) Grow(n int)\n```\n\nDocumentation is strongly encouraged if any of the following are true.\n\n*   It is unclear whether the operation is read-only or mutating:\n\n    ```go\n// Good:\npackage lrucache\n\n// Lookup returns the data associated with the key from the cache.\n//\n// This operation is not safe for concurrent use.\nfunc (*Cache) Lookup(key string) (data []byte, ok bool)\n```\n\n    Why? A cache hit when looking up the key mutate a LRU cache internally. How\n    this is implemented may not be obvious to all readers.\n\n*   Synchronization is provided by the API:\n\n    ```go\n// Good:\npackage fortune_go_proto\n\n// NewFortuneTellerClient returns an *rpc.Client for the FortuneTeller service.\n// It is safe for simultaneous use by multiple goroutines.\nfunc NewFortuneTellerClient(cc *rpc.ClientConn) *FortuneTellerClient\n```\n\n    Why? Stubby provides synchronization.\n\n    **Note:** If the API is a type and the API provides synchronization in\n    entirety, conventionally only the type definition documents the semantics.\n\n*   The API consumes user-implemented types of interfaces, and the interface's\n    consumer has particular concurrency requirements:\n\n    ```go\n// Good:\npackage health\n\n// A Watcher reports the health of some entity (usually a backend service).\n//\n// Watcher methods are safe for simultaneous use by multiple goroutines.\ntype Watcher interface {\n// Watch sends true on the passed-in channel when the Watcher's\n// status has changed.\nWatch(changed chan<- bool) (unwatch func())\n\n\t// Health returns nil if the entity being watched is healthy, or a\n\t// non-nil error explaining why the entity is not healthy.\n\tHealth() error\n}\n```\n\n    Why? Whether an API is safe for use by multiple goroutines is part of its\n    contract.\n\n\n\n#### Cleanup\n\nDocument any explicit cleanup requirements that the API has. Otherwise, callers\nwon't use the API correctly, leading to resource leaks and other possible bugs.\n\nCall out cleanups that are up to the caller:\n\n```go\n// Good:\n// NewTicker returns a new Ticker containing a channel that will send the\n// current time on the channel after each tick.\n//\n// Call Stop to release the Ticker's associated resources when done.\nfunc NewTicker(d Duration) *Ticker\n\nfunc (*Ticker) Stop()\n```\n\nIf it is potentially unclear how to clean up the resources, explain how:\n\n```go\n// Good:\n// Get issues a GET to the specified URL.\n//\n// When err is nil, resp always contains a non-nil resp.Body.\n// Caller should close resp.Body when done reading from it.\n//\n//    resp, err := http.Get(\"http://example.com/\")\n//    if err != nil {\n//        // handle error\n//    }\n//    defer resp.Body.Close()\n//    body, err := io.ReadAll(resp.Body)\nfunc (c *Client) Get(url string) (resp *Response, err error)\n```\n\n#### Errors\n\nDocument significant error sentinel values or error types that your functions\nreturn to callers so that callers can anticipate what types of conditions they\ncan handle in their code.\n\n```go\n// Good:\npackage os\n\n// Read reads up to len(b) bytes from the File and stores them in b. It returns\n// the number of bytes read and any error encountered.\n//\n// At end of file, Read returns 0, io.EOF.\nfunc (*File) Read(b []byte) (n int, err error) {\n```\n\nWhen a function returns a specific error type, correctly note whether the error\nis a pointer receiver or not:\n\n```go\n\t// Good:\n\tpackage os\n\n\ttype PathError struct {\n\t\tOp   string\n\t\tPath string\n\t\tErr  error\n\t}\n\n\t// Chdir changes the current working directory to the named directory.\n\t//\n\t// If there is an error, it will be of type *PathError.\n\tfunc Chdir(dir string) error {\n```\n\nDocumenting whether the values returned are pointer receivers enables callers to\ncorrectly compare the errors using [`errors.Is`], [`errors.As`], and\n[`package cmp`]. This is because a non-pointer value is not equivalent to a\npointer value.\n\n**Note:** In the `Chdir` example, the return type is written as `error` rather\nthan `*PathError` due to\n[how nil interface values work](https://go.dev/doc/faq#nil_error).\n\nDocument overall error conventions in the\n[package's documentation](decisions#package-comments) when the behavior is\napplicable to most errors found in the package:\n\n```go\n\t\t// Good:\n\t\t// Package os provides a platform-independent interface to operating system\n\t\t// functionality.\n\t\t//\n\t\t// Often, more information is available within the error. For example, if a\n\t\t// call that takes a file name fails, such as Open or Stat, the error will\n\t\t// include the failing file name when printed and will be of type *PathError,\n\t\t// which may be unpacked for more information.\n\t\tpackage os\n```\n\nThoughtful application of these approaches can add\n[extra information to errors](#error-extra-info) without much effort and help\ncallers avoid adding redundant annotations.\n\n### Preview\n\nGo features a\n[documentation server](https://pkg.go.dev/golang.org/x/pkgsite/cmd/pkgsite). It\nis recommended to preview the documentation your code produces both before and\nduring the code review process. This helps to validate that the\n[godoc formatting] is rendered correctly.\n\n[godoc formatting]: #godoc-formatting\n\n\n\n### Godoc formatting\n\n[Godoc] provides some specific syntax to [format documentation].\n\n*   A blank line is required to separate paragraphs:\n\n    ```go\n\t\t// Good:\n\t\t// LoadConfig reads a configuration out of the named file.\n\t\t//\n\t\t// See some/shortlink for config file format details.\n    ```\n\n*   Test files can contain [runnable examples] that appear attached to the\n    corresponding documentation in godoc:\n\n    ```go\n\t\t// Good:\n\t\tfunc ExampleConfig_WriteTo() {\n\t\tcfg := &Config{\n\t\tName: \"example\",\n\t\t}\n\t\tif err := cfg.WriteTo(os.Stdout); err != nil {\n\t\tlog.Exitf(\"Failed to write config: %s\", err)\n\t\t}\n\t\t// Output:\n\t\t// {\n\t\t//   \"name\": \"example\"\n\t\t// }\n\t\t}\n    ```\n\n*   Indenting lines by an additional two spaces formats them verbatim:\n\n    ```go\n\t\t// Good:\n\t\t// Update runs the function in an atomic transaction.\n\t\t//\n\t\t// This is typically used with an anonymous TransactionFunc:\n\t\t//\n\t\t//   if err := db.Update(func(state *State) { state.Foo = bar }); err != nil {\n\t\t//     //...\n\t\t//   }\n    ```\n\n    Note, however, that it can often be more appropriate to put code in a\n    runnable example instead of including it in a comment.\n\n    This verbatim formatting can be leveraged for formatting that is not native\n    to godoc, such as lists and tables:\n\n    ```go\n\t\t// Good:\n\t\t// LoadConfig reads a configuration out of the named file.\n\t\t//\n\t\t// LoadConfig treats the following keys in special ways:\n\t\t//   \"import\" will make this configuration inherit from the named file.\n\t\t//   \"env\" if present will be populated with the system environment.\n    ```\n\n*   A single line that begins with a capital letter, contains no punctuation\n    except parentheses and commas, and is followed by another paragraph, is\n    formatted as a header:\n\n    ```go\n\t\t// Good:\n\t\t// The following line is formatted as a heading.\n\t\t//\n\t\t// Using headings\n\t\t//\n\t\t// Headings come with autogenerated anchor tags for easy linking.\n    ```\n\n[Godoc]: https://pkg.go.dev/\n[format documentation]: https://go.dev/doc/comment\n[runnable examples]: decisions#examples\n\n\n\n### Signal boosting\n\nSometimes a line of code looks like something common, but actually isn't. One of\nthe best examples of this is an `err == nil` check (since `err != nil` is much\nmore common). The following two conditional checks are hard to distinguish:\n\n```go\n\t\t// Good:\n\t\tif err := doSomething(); err != nil {\n\t\t// ...\n\t\t}\n```\n\n```go\n\t\t// Bad:\n\t\tif err := doSomething(); err == nil {\n\t\t// ...\n\t\t}\n```\n\nYou can instead \"boost\" the signal of the conditional by adding a comment:\n\n```go\n\t\t// Good:\n\t\tif err := doSomething(); err == nil { // if NO error\n\t\t// ...\n\t\t}\n```\n\nThe comment draws attention to the difference in the conditional.\n\n\n\n## Variable declarations\n\n\n\n### Initialization\n\nFor consistency, prefer `:=` over `var` when initializing a new variable with a\nnon-zero value.\n\n```go\n\t\t// Good:\n\t\ti := 42\n```\n\n```go\n\t\t// Bad:\n\t\tvar i = 42\n```\n\n\n\n### Declaring variables with zero values\n\nThe following declarations use the [zero value]:\n\n```go\n\t\t// Good:\n\t\tvar (\n\t\tcoords Point\n\t\tmagic  [4]byte\n\t\tprimes []int\n\t\t)\n```\n\n[zero value]: https://golang.org/ref/spec#The_zero_value\n\nYou should declare values using the zero value when you want to convey an empty\nvalue that **is ready for later use**. Using composite literals with explicit\ninitialization can be clunky:\n\n```go\n\t\t// Bad:\n\t\tvar (\n\t\tcoords = Point{X: 0, Y: 0}\n\t\tmagic  = [4]byte{0, 0, 0, 0}\n\t\tprimes = []int(nil)\n\t\t)\n```\n\nA common application of zero value declaration is when using a variable as the\noutput when unmarshalling:\n\n```go\n\t\t// Good:\n\t\tvar coords Point\n\t\tif err := json.Unmarshal(data, &coords); err != nil {\n\t\t```\n\nIt is also okay to use the zero value in the following form when you need a\nvariable of a pointer type:\n\n```go\n\t\t// Good:\n\t\tmsg := new(pb.Bar) // or \"&pb.Bar{}\"\n\t\tif err := proto.Unmarshal(data, msg); err != nil {\n\t\t```\n\nIf you need a lock or other field that [must not be copied](decisions#copying)\nin your struct, you can make it a value type to take advantage of zero value\ninitialization. It does mean that the containing type must now be passed via a\npointer and not a value. Methods on the type must take pointer receivers.\n\n```go\n\t\t// Good:\n\t\ttype Counter struct {\n\t\t// This field does not have to be \"*sync.Mutex\". However,\n\t\t// users must now pass *Counter objects between themselves, not Counter.\n\t\tmu   sync.Mutex\n\t\tdata map[string]int64\n\t\t}\n\n\t\t// Note this must be a pointer receiver to prevent copying.\n\t\tfunc (c *Counter) IncrementBy(name string, n int64)\n\t\t```\n\nIt's acceptable to use value types for local variables of composites (such as\nstructs and arrays) even if they contain such uncopyable fields. However, if the\ncomposite is returned by the function, or if all accesses to it end up needing\nto take an address anyway, prefer declaring the variable as a pointer type at\nthe outset. Similarly, protobufs should be declared as pointer types.\n\n```go\n\t\t// Good:\n\t\tfunc NewCounter(name string) *Counter {\n\t\tc := new(Counter) // \"&Counter{}\" is also fine.\n\t\tregisterCounter(name, c)\n\t\treturn c\n\t\t}\n\n\t\tvar msg = new(pb.Bar) // or \"&pb.Bar{}\".\n\t\t```\n\nThis is because `*pb.Something` satisfies [`proto.Message`] while `pb.Something`\ndoes not.\n\n```go\n\t\t// Bad:\n\t\tfunc NewCounter(name string) *Counter {\n\t\tvar c Counter\n\t\tregisterCounter(name, &c)\n\t\treturn &c\n\t\t}\n\n\t\tvar msg = pb.Bar{}\n\t\t```\n\n[`proto.Message`]: https://pkg.go.dev/google.golang.org/protobuf/proto#Message\n\n> **Important:** Map types must be explicitly initialized before they can be\n> modified. However, reading from zero-value maps is perfectly fine.\n>\n> For map and slice types, if the code is particularly performance sensitive and\n> if you know the sizes in advance, see the [size hints](#vardeclsize) section.\n\n\n\n### Composite literals\n\nThe following are [composite literal] declarations:\n\n```go\n\t\t// Good:\n\t\tvar (\n\t\tcoords   = Point{X: x, Y: y}\n\t\tmagic    = [4]byte{'I', 'W', 'A', 'D'}\n\t\tprimes   = []int{2, 3, 5, 7, 11}\n\t\tcaptains = map[string]string{\"Kirk\": \"James Tiberius\", \"Picard\": \"Jean-Luc\"}\n\t\t)\n\t\t```\n\nYou should declare a value using a composite literal when you know initial\nelements or members.\n\nIn contrast, using composite literals to declare empty or memberless values can\nbe visually noisy compared to [zero-value initialization](#vardeclzero).\n\nWhen you need a pointer to a zero value, you have two options: empty composite\nliterals and `new`. Both are fine, but the `new` keyword can serve to remind the\nreader that if a non-zero value were needed, a composite literal wouldn't work:\n\n```go\n\t\t// Good:\n\t\tvar (\n\t\tbuf = new(bytes.Buffer) // non-empty Buffers are initialized with constructors.\n\t\tmsg = new(pb.Message) // non-empty proto messages are initialized with builders or by setting fields one by one.\n\t\t)\n\t\t```\n\n[composite literal]: https://golang.org/ref/spec#Composite_literals\n\n\n\n### Size hints\n\nThe following are declarations that take advantage of size hints in order to\npreallocate capacity:\n\n```go\n\t\t// Good:\n\t\tvar (\n\t\t// Preferred buffer size for target filesystem: st_blksize.\n\t\tbuf = make([]byte, 131072)\n\t\t// Typically process up to 8-10 elements per run (16 is a safe assumption).\n\t\tq = make([]Node, 0, 16)\n\t\t// Each shard processes shardSize (typically 32000+) elements.\n\t\tseen = make(map[string]bool, shardSize)\n\t\t)\n\t\t```\n\nSize hints and preallocation are important steps **when combined with empirical\nanalysis of the code and its integrations**, to create performance-sensitive and\nresource-efficient code.\n\nMost code does not need a size hint or preallocation, and can allow the runtime\nto grow the slice or map as necessary. It is acceptable to preallocate when the\nfinal size is known (e.g. when converting between a map and a slice) but this is\nnot a readability requirement, and may not be worth the clutter in small cases.\n\n**Warning:** Preallocating more memory than you need can waste memory in the\nfleet or even harm performance. When in doubt, see\n[GoTip #3: Benchmarking Go Code] and default to a\n[zero initialization](#vardeclzero) or a\n[composite literal declaration](#vardeclcomposite).\n\n[GoTip #3: Benchmarking Go Code]: https://google.github.io/styleguide/go/index.html#gotip\n\n\n\n### Channel direction\n\nSpecify [channel direction] where possible.\n\n```go\n\t\t// Good:\n\t\t// sum computes the sum of all of the values. It reads from the channel until\n\t\t// the channel is closed.\n\t\tfunc sum(values <-chan int) int {\n\t\t// ...\n\t\t}\n\t\t```\n\nThis prevents casual programming errors that are possible without specification:\n\n```go\n\t\t// Bad:\n\t\tfunc sum(values chan int) (out int) {\n\t\tfor v := range values {\n\t\tout += v\n\t\t}\n\t\t// values must already be closed for this code to be reachable, which means\n\t\t// a second close triggers a panic.\n\t\tclose(values)\n\t\t}\n\t\t```\n\nWhen the direction is specified, the compiler catches simple errors like this.\nIt also helps to convey a measure of ownership to the type.\n\n\n## Function argument lists\n\nDon't let the signature of a function get too long. As more parameters are added\nto a function, the role of individual parameters becomes less clear, and\nadjacent parameters of the same type become easier to confuse. Functions with\nlarge numbers of arguments are less memorable and more difficult to read at the\ncall-site.\n\nWhen designing an API, consider splitting a highly configurable function whose\nsignature is growing complex into several simpler ones. These can share an\n(unexported) implementation if necessary.\n\nWhere a function requires many inputs, consider introducing an [option struct]\nfor some of the arguments or employing the more advanced [variadic options]\ntechnique. The primary consideration for which strategy to choose should be how\nthe function call looks across all expected use cases.\n\nThe recommendations below primarily apply to exported APIs, which are held to a\nhigher standard than unexported ones. These techniques may be unnecessary for\nyour use case. Use your judgment, and balance the principles of [clarity] and\n[least mechanism].\n\n### Option structure\n\nAn option structure is a struct type that collects some or all of the arguments\nof a function or method, that is then passed as the last argument to the\nfunction or method. (The struct should be exported only if it is used in an\nexported function.)\n\nUsing an option structure has a number of benefits:\n\n*   The struct literal includes both fields and values for each argument, which\n    makes them self-documenting and harder to swap.\n*   Irrelevant or \"default\" fields can be omitted.\n*   Callers can share the options struct and write helpers to operate on it.\n*   Structs provide cleaner per-field documentation than function arguments.\n*   Option structs can grow over time without impacting call-sites.\n\nHere is an example of a function that could be improved:\n\n```go\n\t\t// Bad:\n\t\tfunc EnableReplication(ctx context.Context, config *replicator.Config, primaryRegions, readonlyRegions []string, replicateExisting, overwritePolicies bool, replicationInterval time.Duration, copyWorkers int, healthWatcher health.Watcher) {\n\t\t// ...\n\t\t}\n\t\t```\n\nThe function above could be rewritten with an option structure as follows:\n\n```go\n\t\t// Good:\n\t\ttype ReplicationOptions struct {\n\t\tConfig              *replicator.Config\n\t\tPrimaryRegions      []string\n\t\tReadonlyRegions     []string\n\t\tReplicateExisting   bool\n\t\tOverwritePolicies   bool\n\t\tReplicationInterval time.Duration\n\t\tCopyWorkers         int\n\t\tHealthWatcher       health.Watcher\n\t\t}\n\n\t\tfunc EnableReplication(ctx context.Context, opts ReplicationOptions) {\n\t\t// ...\n\t\t}\n\t\t```\n\nThe function can then be called in a different package:\n\n```go\n\t\t// Good:\n\t\tfunc foo(ctx context.Context) {\n\t\t// Complex call:\n\t\tstorage.EnableReplication(ctx, storage.ReplicationOptions{\n\t\tConfig:              config,\n\t\tPrimaryRegions:      []string{\"us-east1\", \"us-central2\", \"us-west3\"},\n\t\tReadonlyRegions:     []string{\"us-east5\", \"us-central6\"},\n\t\tOverwritePolicies:   true,\n\t\tReplicationInterval: 1 * time.Hour,\n\t\tCopyWorkers:         100,\n\t\tHealthWatcher:       watcher,\n\t\t})\n\n\t\t// Simple call:\n\t\tstorage.EnableReplication(ctx, storage.ReplicationOptions{\n\t\tConfig:         config,\n\t\tPrimaryRegions: []string{\"us-east1\", \"us-central2\", \"us-west3\"},\n\t\t})\n\t\t}\n\t\t```\n\n**Note:** [Contexts are never included in option structs](decisions#contexts).\n\nThis option is often preferred when some of the following apply:\n\n*   All callers need to specify one or more of the options.\n*   A large number of callers need to provide many options.\n*   The options are shared between multiple functions that the user will call.\n\n\n\n### Variadic options\n\nUsing variadic options, exported functions are created which return closures\nthat can be passed to the [variadic (`...`) parameter] of a function. The\nfunction takes as its parameters the values of the option (if any), and the\nreturned closure accepts a mutable reference (usually a pointer to a struct\ntype) that will be updated based on the inputs.\n\n[variadic (`...`) parameter]: https://golang.org/ref/spec#Passing_arguments_to_..._parameters\n\nUsing variadic options can provide a number of benefits:\n\n*   Options take no space at a call-site when no configuration is needed.\n*   Options are still values, so callers can share them, write helpers, and\n    accumulate them.\n*   Options can accept multiple parameters (e.g. `cartesian.Translate(dx, dy\n\t\tint) TransformOption`).\n*   The option functions can return a named type to group options together in\n    godoc.\n*   Packages can allow (or prevent) third-party packages to define (or from\n    defining) their own options.\n\n**Note:** Using variadic options requires a substantial amount of additional\ncode (see the following example), so it should only be used when the advantages\noutweigh the overhead.\n\nHere is an example of a function that could be improved:\n\n```go\n\t\t// Bad:\n\t\tfunc EnableReplication(ctx context.Context, config *placer.Config, primaryCells, readonlyCells []string, replicateExisting, overwritePolicies bool, replicationInterval time.Duration, copyWorkers int, healthWatcher health.Watcher) {\n\t\t...\n\t\t}\n\t\t```\n\nThe example above could be rewritten with variadic options as follows:\n\n```go\n\t\t// Good:\n\t\ttype replicationOptions struct {\n\t\treadonlyCells       []string\n\t\treplicateExisting   bool\n\t\toverwritePolicies   bool\n\t\treplicationInterval time.Duration\n\t\tcopyWorkers         int\n\t\thealthWatcher       health.Watcher\n\t\t}\n\n\t\t// A ReplicationOption configures EnableReplication.\n\t\ttype ReplicationOption func(*replicationOptions)\n\n\t\t// ReadonlyCells adds additional cells that should additionally\n\t\t// contain read-only replicas of the data.\n\t\t//\n\t\t// Passing this option multiple times will add additional\n\t\t// read-only cells.\n\t\t//\n\t\t// Default: none\n\t\tfunc ReadonlyCells(cells ...string) ReplicationOption {\n\t\treturn func(opts *replicationOptions) {\n\t\topts.readonlyCells = append(opts.readonlyCells, cells...)\n\t\t}\n\t\t}\n\n\t\t// ReplicateExisting controls whether files that already exist in the\n\t\t// primary cells will be replicated.  Otherwise, only newly-added\n\t\t// files will be candidates for replication.\n\t\t//\n\t\t// Passing this option again will overwrite earlier values.\n\t\t//\n\t\t// Default: false\n\t\tfunc ReplicateExisting(enabled bool) ReplicationOption {\n\t\treturn func(opts *replicationOptions) {\n\t\topts.replicateExisting = enabled\n\t\t}\n\t\t}\n\n\t\t// ... other options ...\n\n\t\t// DefaultReplicationOptions control the default values before\n\t\t// applying options passed to EnableReplication.\n\t\tvar DefaultReplicationOptions = []ReplicationOption{\n\t\tOverwritePolicies(true),\n\t\tReplicationInterval(12 * time.Hour),\n\t\tCopyWorkers(10),\n\t\t}\n\n\t\tfunc EnableReplication(ctx context.Context, config *placer.Config, primaryCells []string, opts ...ReplicationOption) {\n\t\tvar options replicationOptions\n\t\tfor _, opt := range DefaultReplicationOptions {\n\t\topt(&options)\n\t\t}\n\t\tfor _, opt := range opts {\n\t\topt(&options)\n\t\t}\n\t\t}\n\t\t```\n\nThe function can then be called in a different package:\n\n```go\n\t\t// Good:\n\t\tfunc foo(ctx context.Context) {\n\t\t// Complex call:\n\t\tstorage.EnableReplication(ctx, config, []string{\"po\", \"is\", \"ea\"},\n\t\tstorage.ReadonlyCells(\"ix\", \"gg\"),\n\t\tstorage.OverwritePolicies(true),\n\t\tstorage.ReplicationInterval(1*time.Hour),\n\t\tstorage.CopyWorkers(100),\n\t\tstorage.HealthWatcher(watcher),\n\t\t)\n\n\t\t// Simple call:\n\t\tstorage.EnableReplication(ctx, config, []string{\"po\", \"is\", \"ea\"})\n\t\t}\n\t\t```\n\nPrefer this option when many of the following apply:\n\n*   Most callers will not need to specify any options.\n*   Most options are used infrequently.\n*   There are a large number of options.\n*   Options require arguments.\n*   Options could fail or be set incorrectly (in which case the option function\n    returns an `error`).\n*   Options require a lot of documentation that can be hard to fit in a struct.\n*   Users or other packages can provide custom options.\n\nOptions in this style should accept parameters rather than using presence to\nsignal their value; the latter can make dynamic composition of arguments much\nmore difficult. For example, binary settings should accept a boolean (e.g.\n`rpc.FailFast(enable bool)` is preferable to `rpc.EnableFailFast()`). An\nenumerated option should accept an enumerated constant (e.g.\n`log.Format(log.Capacitor)` is preferable to `log.CapacitorFormat()`). The\nalternative makes it much more difficult for users who must programmatically\nchoose which options to pass; such users are forced to change the actual\ncomposition of the parameters rather than simply changing the arguments to the\noptions. Don't assume that all users will know the full set of options\nstatically.\n\nIn general, options should be processed in order. If there is a conflict or if a\nnon-cumulative option is passed multiple times, the last argument should win.\n\nThe parameter to the option function is generally unexported in this pattern, to\nrestrict the options to being defined only within the package itself. This is a\ngood default, though there may be times when it is appropriate to allow other\npackages to define options.\n\nSee [Rob Pike's original blog post] and [Dave Cheney's talk] for a more in-depth\nlook at how these options can be used.\n\n[Rob Pike's original blog post]: http://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html\n[Dave Cheney's talk]: https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis\n\n\n\n## Complex command-line interfaces\n\nSome programs wish to present users with a rich command-line interface that\nincludes sub-commands. For example, `kubectl create`, `kubectl run`, and many\nother sub-commands are all provided by the program `kubectl`. There are at least\nthe following libraries in common use for achieving this.\n\nIf you don't have a preference or other considerations are equal, [subcommands]\nis recommended, since it is the simplest and is easy to use correctly. However,\nif you need different features that it doesn't provide, pick one of the other\noptions.\n\n*   **[cobra]**\n\n    *   Flag convention: getopt\n    *   Common outside the Google codebase.\n    *   Many extra features.\n    *   Pitfalls in usage (see below).\n\n*   **[subcommands]**\n\n    *   Flag convention: Go\n    *   Simple and easy to use correctly.\n    *   Recommended if you don't need extra features.\n\n**Warning**: cobra command functions should use `cmd.Context()` to obtain a\ncontext rather than creating their own root context with `context.Background`.\nCode that uses the subcommands package already receives the correct context as a\nfunction parameter.\n\nYou are not required to place each subcommand in a separate package, and it is\noften not necessary to do so. Apply the same considerations about package\nboundaries as in any Go codebase. If your code can be used both as a library and\nas a binary, it is usually beneficial to separate the CLI code and the library,\nmaking the CLI just one more of its clients. (This is not specific to CLIs that\nhave subcommands, but is mentioned here because it is a common place where it\ncomes up.)\n\n[subcommands]: https://pkg.go.dev/github.com/google/subcommands\n[cobra]: https://pkg.go.dev/github.com/spf13/cobra\n\n\n\n## Tests\n\n\n\n### Leave testing to the `Test` function\n\n<!-- Note to maintainers: This section overlaps with decisions#assert and\ndecisions#mark-test-helpers. The point is not to repeat information, but\nto have one place that summarizes the distinction that newcomers to the\nlanguage often wonder about. -->\n\nGo distinguishes between \"test helpers\" and \"assertion helpers\":\n\n*   **Test helpers** are functions that do setup or cleanup tasks. All failures\n    that occur in test helpers are expected to be failures of the environment\n    (not from the code under test) — for example when a test database cannot be\n    started because there are no more free ports on this machine. For functions\n    like these, calling `t.Helper` is often appropriate to\n    [mark them as a test helper]. See [error handling in test helpers] for more\n    details.\n\n*   **Assertion helpers** are functions that check the correctness of a system\n    and fail the test if an expectation is not met. Assertion helpers are\n    [not considered idiomatic] in Go.\n\nThe purpose of a test is to report pass/fail conditions of the code under test.\nThe ideal place to fail a test is within the `Test` function itself, as that\nensures that [failure messages] and the test logic are clear.\n\n[mark them as a test helper]: decisions#mark-test-helpers\n[error handling in test helpers]: #test-helper-error-handling\n[not considered idiomatic]: decisions#assert\n[failure messages]: decisions#useful-test-failures\n\nAs your testing code grows, it may become necessary to factor out some\nfunctionality to separate functions. Standard software engineering\nconsiderations still apply, as *test code is still code*. If the functionality\ndoes not interact with the testing framework, then all of the usual rules apply.\nWhen the common code interacts with the framework, however, some care must be\ntaken to avoid common pitfalls that can lead to uninformative failure messages\nand unmaintainable tests.\n\nIf many separate test cases require the same validation logic, arrange the test\nin one of the following ways instead of using assertion helpers or complex\nvalidation functions:\n\n*   Inline the logic (both the validation and the failure) in the `Test`\n    function, even if it is repetitive. This works best in simple cases.\n*   If inputs are similar, consider unifying them into a [table-driven test]\n    while keeping the logic inlined in the loop. This helps to avoid repetition\n    while keeping the validation and failure in the `Test`.\n*   If there are multiple callers who need the same validation function but\n    table tests are not suitable (typically because the inputs are not simple\n    enough or the validation is required as part of a sequence of operations),\n    arrange the validation function so that it returns a value (typically an\n    `error`) rather than taking a `testing.T` parameter and using it to fail the\n    test. Use logic within the `Test` to decide whether to fail, and to provide\n    [useful test failures]. You can also create test helpers to factor out\n    common boilerplate setup code.\n\nThe design outlined in the last point maintains orthogonality. For example,\n[package `cmp`] is not designed to fail tests, but rather to compare (and to\ndiff) values. It therefore does not need to know about the context in which the\ncomparison was made, since the caller can supply that. If your common testing\ncode provides a `cmp.Transformer` for your data type, that can often be the\nsimplest design. For other validations, consider returning an `error` value.\n\n```go\n\t\t// Good:\n\t\t// polygonCmp returns a cmp.Option that equates s2 geometry objects up to\n\t\t// some small floating-point error.\n\t\tfunc polygonCmp() cmp.Option {\n\t\treturn cmp.Options{\n\t\tcmp.Transformer(\"polygon\", func(p *s2.Polygon) []*s2.Loop { return p.Loops() }),\n\t\tcmp.Transformer(\"loop\", func(l *s2.Loop) []s2.Point { return l.Vertices() }),\n\t\tcmpopts.EquateApprox(0.00000001, 0),\n\t\tcmpopts.EquateEmpty(),\n\t\t}\n\t\t}\n\n\t\tfunc TestFenceposts(t *testing.T) {\n\t\t// This is a test for a fictional function, Fenceposts, which draws a fence\n\t\t// around some Place object. The details are not important, except that\n\t\t// the result is some object that has s2 geometry (github.com/golang/geo/s2)\n\t\tgot := Fencepost(tomsDiner, 1*meter)\n\t\tif diff := cmp.Diff(want, got, polygonCmp()); diff != \"\" {\n\t\tt.Errorf(\"Fencepost(tomsDiner, 1m) returned unexpected diff (-want+got):\\n%v\", diff)\n\t\t}\n\t\t}\n\n\t\tfunc FuzzFencepost(f *testing.F) {\n\t\t// Fuzz test (https://go.dev/doc/fuzz) for the same.\n\n\t\tf.Add(tomsDiner, 1*meter)\n\t\tf.Add(school, 3*meter)\n\n\t\tf.Fuzz(func(t *testing.T, geo Place, padding Length) {\n\t\tgot := Fencepost(geo, padding)\n\t\t// Simple reference implementation: not used in prod, but easy to\n\t\t// reason about and therefore useful to check against in random tests.\n\t\treference := slowFencepost(geo, padding)\n\n\t\t// In the fuzz test, inputs and outputs can be large so don't\n\t\t// bother with printing a diff. cmp.Equal is enough.\n\t\tif !cmp.Equal(got, reference, polygonCmp()) {\n\t\tt.Errorf(\"Fencepost returned wrong placement\")\n\t\t}\n\t\t})\n\t\t}\n\t\t```\n\nThe `polygonCmp` function is agnostic about how it's called; it doesn't take a\nconcrete input type nor does it police what to do in case two objects don't\nmatch. Therefore, more callers can make use of it.\n\n**Note:** There is an analogy between test helpers and plain library code. Code\nin libraries should usually [not panic] except in rare circumstances; code\ncalled from a test should not stop the test unless there is\n[no point in proceeding].\n\n[table-driven test]: decisions#table-driven-tests\n[useful test failures]: decisions#useful-test-failures\n[package `cmp`]: https://pkg.go.dev/github.com/google/go-cmp/cmp\n[not panic]: decisions#dont-panic\n[no point in proceeding]: #t-fatal\n\n\n\n### Designing extensible validation APIs\n\nMost of the advice about testing in the style guide is about testing your own\ncode. This section is about how to provide facilities for other people to test\nthe code they write to ensure that it conforms to your library's requirements.\n\n\n\n#### Acceptance testing\n\nSuch testing is referred to as [acceptance testing]. The premise of this kind of\ntesting is that the person using the test does not know every last detail of\nwhat goes on in the test; they just hand the inputs over to the testing facility\nto do the work. This can be thought of as a form of [inversion of control].\n\nIn a typical Go test, the test function controls the program flow, and the\n[no assert](decisions#assert) and [test functions](#test-functions) guidance\nencourages you to keep it that way. This section explains how to author support\nfor these tests in a way that is consistent with Go style.\n\nBefore diving into how, consider an example from [`io/fs`], excerpted below:\n\n```go\n\t\ttype FS interface {\n\t\tOpen(name string) (File, error)\n\t\t}\n\t\t```\n\nWhile there exist well-known implementations of `fs.FS`, a Go developer may be\nexpected to author one. To help validate the user-implemented `fs.FS` is\ncorrect, a generic library has been provided in [`testing/fstest`] called\n[`fstest.TestFS`]. This API treats the implementation as a blackbox to make sure\nit upholds the most basic parts of the `io/fs` contract.\n\n[acceptance testing]: https://en.wikipedia.org/wiki/Acceptance_testing\n[inversion of control]: https://en.wikipedia.org/wiki/Inversion_of_control\n[`io/fs`]: https://pkg.go.dev/io/fs\n[`testing/fstest`]: https://pkg.go.dev/testing/fstest\n[`fstest.TestFS`]: https://pkg.go.dev/testing/fstest#TestFS\n\n\n\n#### Writing an acceptance test\n\nNow that we know what an acceptance test is and why you might use one, let's\nexplore building an acceptance test for `package chess`, a package used to\nsimulate chess games. Users of `chess` are expected to implement the\n`chess.Player` interface. These implementations are the primary thing we will\nvalidate. Our acceptance test concerns itself with whether the player\nimplementation makes legal moves, not whether the moves are smart.\n\n1.  Create a new package for the validation behavior,\n    [customarily named](#naming-doubles-helper-package) by appending the word\n    `test` to the package name (for example, `chesstest`).\n\n1.  Create the function that performs the validation by accepting the\n    implementation under test as an argument and exercises it:\n\n    ```go\n\t\t// ExercisePlayer tests a Player implementation in a single turn on a board.\n\t\t// The board itself is spot checked for sensibility and correctness.\n\t\t//\n\t\t// It returns a nil error if the player makes a correct move in the context\n\t\t// of the provided board. Otherwise ExercisePlayer returns one of this\n\t\t// package's errors to indicate how and why the player failed the\n\t\t// validation.\n\t\tfunc ExercisePlayer(b *chess.Board, p chess.Player) error\n\t\t```\n\n    The test should note which invariants are broken and how. Your design can\n    choose between two disciplines for failure reporting:\n\n    *   **Fail fast**: return an error as soon as the implementation violates an\n        invariant.\n\n        This is the simplest approach, and it works well if the acceptance test\n        is expected to execute quickly. Simple error [sentinels] and\n        [custom types] can be used easily here, which conversely makes testing\n        the acceptance test easy.\n\n        ```go\n\t\tfor color, army := range b.Armies {\n\t\t// The king should never leave the board, because the game ends at\n\t\t// checkmate.\n\t\tif army.King == nil {\n\t\treturn &MissingPieceError{Color: color, Piece: chess.King}\n\t\t}\n\t\t}\n\t\t```\n\n    *   **Aggregate all failures**: collect all failures, and report them all.\n\n        This approach resembles the [keep going](decisions#keep-going) guidance\n        in feel and may be preferable if the acceptance test is expected to\n        execute slowly.\n\n        How you aggregate the failures should be dictated by whether you want to\n        give users the ability or yourself the ability to interrogate individual\n        failures (for example, for you to test your acceptance test). Below\n        demonstrates using a [custom error type][custom types] that\n        [aggregates errors]:\n\n        ```go\n\t\tvar badMoves []error\n\n\t\tmove := p.Move()\n\t\tif putsOwnKingIntoCheck(b, move) {\n\t\tbadMoves = append(badMoves, PutsSelfIntoCheckError{Move: move})\n\t\t}\n\n\t\tif len(badMoves) > 0 {\n\t\treturn SimulationError{BadMoves: badMoves}\n\t\t}\n\t\treturn nil\n\t\t```\n\nThe acceptance test should honor the [keep going](decisions#keep-going) guidance\nby not calling `t.Fatal` unless the test detects a broken invariant in the\nsystem being exercised.\n\nFor example, `t.Fatal` should be reserved for exceptional cases such as\n[setup failure](#test-helper-error-handling) as usual:\n\n```go\n\t\tfunc ExerciseGame(t *testing.T, cfg *Config, p chess.Player) error {\n\t\tt.Helper()\n\n\t\tif cfg.Simulation == Modem {\n\t\tconn, err := modempool.Allocate()\n\t\tif err != nil {\n\t\tt.Fatalf(\"No modem for the opponent could be provisioned: %v\", err)\n\t\t}\n\t\tt.Cleanup(func() { modempool.Return(conn) })\n\t\t}\n\t\t// Run acceptance test (a whole game).\n\t\t}\n\t\t```\n\nThis technique can help you create concise, canonical validations. But do not\nattempt to use it to bypass the [guidance on assertions](decisions#assert).\n\nThe final product should be in a form similar to this for end users:\n\n```go\n\t\t// Good:\n\t\tpackage deepblue_test\n\n\t\timport (\n\t\t\"chesstest\"\n\t\t\"deepblue\"\n\t\t)\n\n\t\tfunc TestAcceptance(t *testing.T) {\n\t\tplayer := deepblue.New()\n\t\terr := chesstest.ExerciseGame(t, chesstest.SimpleGame, player)\n\t\tif err != nil {\n\t\tt.Errorf(\"Deep Blue player failed acceptance test: %v\", err)\n\t\t}\n\t\t}\n\t\t```\n\n[sentinels]: https://google.github.io/styleguide/go/index.html#gotip\n[custom types]: https://google.github.io/styleguide/go/index.html#gotip\n[aggregates errors]: https://google.github.io/styleguide/go/index.html#gotip\n\n\n\n### Use real transports\n\nWhen testing component integrations, especially where HTTP or RPC are used as\nthe underlying transport between the components, prefer using the real\nunderlying transport to connect to the test version of the backend.\n\nFor example, suppose the code you want to test (sometimes referred to as \"system\nunder test\" or SUT) interacts with a backend that implements the\n[long running operations] API. To test your SUT, use a real [OperationsClient]\nthat is connected to a\n[test double](https://abseil.io/resources/swe-book/html/ch13.html#basic_concepts)\n(e.g., a mock, stub, or fake) of the [OperationsServer].\n\n[test double]: https://abseil.io/resources/swe-book/html/ch13.html#basic_concepts\n[long running operations]: https://pkg.go.dev/google.golang.org/genproto/googleapis/longrunning\n[OperationsClient]: https://pkg.go.dev/google.golang.org/genproto/googleapis/longrunning#OperationsClient\n[OperationsServer]: https://pkg.go.dev/google.golang.org/genproto/googleapis/longrunning#OperationsServer\n\nThis is recommended over hand-implementing the client, due to the complexity of\nimitating client behavior correctly. By using the production client with a\ntest-specific server, you ensure your test is using as much of the real code as\npossible.\n\n**Tip:** Where possible, use a testing library provided by the authors of the\nservice under test.\n\n\n\n### `t.Error` vs. `t.Fatal`\n\nAs discussed in [decisions](decisions#keep-going), tests should generally not\nabort at the first encountered problem.\n\nHowever, some situations require that the test not proceed. Calling `t.Fatal` is\nappropriate when some piece of test setup fails, especially in\n[test setup helpers], without which you cannot run the rest of the test. In a\ntable-driven test, `t.Fatal` is appropriate for failures that set up the whole\ntest function before the test loop. Failures that affect a single entry in the\ntest table, which make it impossible to continue with that entry, should be\nreported as follows:\n\n*   If you're not using `t.Run` subtests, use `t.Error` followed by a `continue`\n    statement to move on to the next table entry.\n*   If you're using subtests (and you're inside a call to `t.Run`), use\n    `t.Fatal`, which ends the current subtest and allows your test case to\n    progress to the next subtest.\n\n**Warning:** It is not always safe to call `t.Fatal` and similar functions.\n[More details here](#t-fatal-goroutine).\n\n[test setup helpers]: #test-helper-error-handling\n\n\n\n### Error handling in test helpers\n\n**Note:** This section discusses [test helpers] in the sense Go uses the term:\nfunctions that perform test setup and cleanup, not common assertion facilities.\nSee the [test functions](#test-functions) section for more discussion.\n\n[test helpers]: decisions#mark-test-helpers\n\nOperations performed by a test helper sometimes fail. For example, setting up a\ndirectory with files involves I/O, which can fail. When test helpers fail, their\nfailure often signifies that the test cannot continue, since a setup\nprecondition failed. When this happens, prefer calling one of the `Fatal`\nfunctions in the helper:\n\n```go\n\t\t// Good:\n\t\tfunc mustAddGameAssets(t *testing.T, dir string) {\n\t\tt.Helper()\n\t\tif err := os.WriteFile(path.Join(dir, \"pak0.pak\"), pak0, 0644); err != nil {\n\t\tt.Fatalf(\"Setup failed: could not write pak0 asset: %v\", err)\n\t\t}\n\t\tif err := os.WriteFile(path.Join(dir, \"pak1.pak\"), pak1, 0644); err != nil {\n\t\tt.Fatalf(\"Setup failed: could not write pak1 asset: %v\", err)\n\t\t}\n\t\t}\n\t\t```\n\nThis keeps the calling side cleaner than if the helper were to return the error\nto the test itself:\n\n```go\n\t\t// Bad:\n\t\tfunc addGameAssets(t *testing.T, dir string) error {\n\t\tt.Helper()\n\t\tif err := os.WriteFile(path.Join(d, \"pak0.pak\"), pak0, 0644); err != nil {\n\t\treturn err\n\t\t}\n\t\tif err := os.WriteFile(path.Join(d, \"pak1.pak\"), pak1, 0644); err != nil {\n\t\treturn err\n\t\t}\n\t\treturn nil\n\t\t}\n\t\t```\n\n**Warning:** It is not always safe to call `t.Fatal` and similar functions.\n[More details](#t-fatal-goroutine) here.\n\nThe failure message should include a description of what happened. This is\nimportant, as you may be providing a testing API to many users, especially as\nthe number of error-producing steps in the helper increases. When the test\nfails, the user should know where, and why.\n\n**Tip:** Go 1.14 introduced a [`t.Cleanup`] function that can be used to\nregister cleanup functions that run when your test completes. The function also\nworks with test helpers. See\n[GoTip #4: Cleaning Up Your Tests](https://google.github.io/styleguide/go/index.html#gotip)\nfor guidance on simplifying test helpers.\n\nThe snippet below in a fictional file called `paint_test.go` demonstrates how\n`(*testing.T).Helper` influences failure reporting in a Go test:\n\n```go\n\t\tpackage paint_test\n\n\t\timport (\n\t\t\"fmt\"\n\t\t\"testing\"\n\t\t)\n\n\t\tfunc paint(color string) error {\n\t\treturn fmt.Errorf(\"no %q paint today\", color)\n\t\t}\n\n\t\tfunc badSetup(t *testing.T) {\n\t\t// This should call t.Helper, but doesn't.\n\t\tif err := paint(\"taupe\"); err != nil {\n\t\tt.Fatalf(\"Could not paint the house under test: %v\", err) // line 15\n\t\t}\n\t\t}\n\n\t\tfunc mustGoodSetup(t *testing.T) {\n\t\tt.Helper()\n\t\tif err := paint(\"lilac\"); err != nil {\n\t\tt.Fatalf(\"Could not paint the house under test: %v\", err)\n\t\t}\n\t\t}\n\n\t\tfunc TestBad(t *testing.T) {\n\t\tbadSetup(t)\n\t\t// ...\n\t\t}\n\n\t\tfunc TestGood(t *testing.T) {\n\t\tmustGoodSetup(t) // line 32\n\t\t// ...\n\t\t}\n\t\t```\n\nHere is an example of this output when run. Note the highlighted text and how it\ndiffers:\n\n```text\n\t\t=== RUN   TestBad\n\t\tpaint_test.go:15: Could not paint the house under test: no \"taupe\" paint today\n\t\t--- FAIL: TestBad (0.00s)\n\t\t=== RUN   TestGood\n\t\tpaint_test.go:32: Could not paint the house under test: no \"lilac\" paint today\n\t\t--- FAIL: TestGood (0.00s)\n\t\tFAIL\n\t\t```\n\nThe error with `paint_test.go:15` refers to the line of the setup function that\nfailed in `badSetup`:\n\n`t.Fatalf(\"Could not paint the house under test: %v\", err)`\n\nWhereas `paint_test.go:32` refers to the line of the test that failed in\n`TestGood`:\n\n`goodSetup(t)`\n\nCorrectly using `(*testing.T).Helper` attributes the location of the failure\nmuch better when:\n\n*   the helper functions grow\n*   the helper functions call other helpers\n*   the amount of helper usage in the test functions grow\n\n**Tip:** If a helper calls `(*testing.T).Error` or `(*testing.T).Fatal`, provide\nsome context in the format string to help determine what went wrong and why.\n\n**Tip:** If nothing a helper does can cause a test to fail, it doesn't need to\ncall `t.Helper`. Simplify its signature by removing `t` from the function\nparameter list.\n\n[`t.Cleanup`]: https://pkg.go.dev/testing#T.Cleanup\n\n\n\n### Don't call `t.Fatal` from separate goroutines\n\nAs [documented in package testing](https://pkg.go.dev/testing#T), it is\nincorrect to call `t.FailNow`, `t.Fatal`, etc. from any goroutine but the one\nrunning the Test function (or the subtest). If your test starts new goroutines,\nthey must not call these functions from inside these goroutines.\n\n[Test helpers](#test-functions) usually don't signal failure from new\ngoroutines, and therefore it is all right for them to use `t.Fatal`. If in\ndoubt, call `t.Error` and return instead.\n\n```go\n\t\t// Good:\n\t\tfunc TestRevEngine(t *testing.T) {\n\t\tengine, err := Start()\n\t\tif err != nil {\n\t\tt.Fatalf(\"Engine failed to start: %v\", err)\n\t\t}\n\n\t\tnum := 11\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(num)\n\t\tfor i := 0; i < num; i++ {\n\t\tgo func() {\n\t\tdefer wg.Done()\n\t\tif err := engine.Vroom(); err != nil {\n\t\t// This cannot be t.Fatalf.\n\t\tt.Errorf(\"No vroom left on engine: %v\", err)\n\t\treturn\n\t\t}\n\t\tif rpm := engine.Tachometer(); rpm > 1e6 {\n\t\tt.Errorf(\"Inconceivable engine rate: %d\", rpm)\n\t\t}\n\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\tif seen := engine.NumVrooms(); seen != num {\n\t\tt.Errorf(\"engine.NumVrooms() = %d, want %d\", seen, num)\n\t\t}\n\t\t}\n\t\t```\n\nAdding `t.Parallel` to a test or subtest does not make it unsafe to call\n`t.Fatal`.\n\nWhen all calls to the `testing` API are in the [test function](#test-functions),\nit is usually easy to spot incorrect usage because the `go` keyword is plain to\nsee. Passing `testing.T` arguments around makes tracking such usage harder.\nTypically, the reason for passing these arguments is to introduce a test helper,\nand those should not depend on the system under test. Therefore, if a test\nhelper [registers a fatal test failure](#test-helper-error-handling), it can and\nshould do so from the test's goroutine.\n\n\n\n### Use field names in struct literals\n\n\n\nIn table-driven tests, prefer to specify field names when initializing test case\nstruct literals. This is helpful when the test cases cover a large amount of\nvertical space (e.g. more than 20-30 lines), when there are adjacent fields with\nthe same type, and also when you wish to omit fields which have the zero value.\nFor example:\n\n```go\n\t\t// Good:\n\t\tfunc TestStrJoin(t *testing.T) {\n\t\ttests := []struct {\n\t\tslice     []string\n\t\tseparator string\n\t\tskipEmpty bool\n\t\twant      string\n\t\t}{\n\t\t{\n\t\tslice:     []string{\"a\", \"b\", \"\"},\n\t\tseparator: \",\",\n\t\twant:      \"a,b,\",\n\t\t},\n\t\t{\n\t\tslice:     []string{\"a\", \"b\", \"\"},\n\t\tseparator: \",\",\n\t\tskipEmpty: true,\n\t\twant:      \"a,b\",\n\t\t},\n\t\t// ...\n\t\t}\n\t\t// ...\n\t\t}\n\t\t```\n\n\n\n### Keep setup code scoped to specific tests\n\nWhere possible, setup of resources and dependencies should be as closely scoped\nto specific test cases as possible. For example, given a setup function:\n\n```go\n\t\t// mustLoadDataSet loads a data set for the tests.\n\t\t//\n\t\t// This example is very simple and easy to read. Often realistic setup is more\n\t\t// complex, error-prone, and potentially slow.\n\t\tfunc mustLoadDataset(t *testing.T) []byte {\n\t\tt.Helper()\n\t\tdata, err := os.ReadFile(\"path/to/your/project/testdata/dataset\")\n\n\t\tif err != nil {\n\t\tt.Fatalf(\"Could not load dataset: %v\", err)\n\t\t}\n\t\treturn data\n\t\t}\n\t\t```\n\nCall `mustLoadDataset` explicitly in test functions that need it:\n\n```go\n\t\t// Good:\n\t\tfunc TestParseData(t *testing.T) {\n\t\tdata := mustLoadDataset(t)\n\t\tparsed, err := ParseData(data)\n\t\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error parsing data: %v\", err)\n\t\t}\n\t\twant := &DataTable{ /* ... */ }\n\t\tif got := parsed; !cmp.Equal(got, want) {\n\t\tt.Errorf(\"ParseData(data) = %v, want %v\", got, want)\n\t\t}\n\t\t}\n\n\t\tfunc TestListContents(t *testing.T) {\n\t\tdata := mustLoadDataset(t)\n\t\tcontents, err := ListContents(data)\n\t\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error listing contents: %v\", err)\n\t\t}\n\t\twant := []string{ /* ... */ }\n\t\tif got := contents; !cmp.Equal(got, want) {\n\t\tt.Errorf(\"ListContents(data) = %v, want %v\", got, want)\n\t\t}\n\t\t}\n\n\t\tfunc TestRegression682831(t *testing.T) {\n\t\tif got, want := guessOS(\"zpc79.example.com\"), \"grhat\"; got != want {\n\t\tt.Errorf(`guessOS(\"zpc79.example.com\") = %q, want %q`, got, want)\n\t\t}\n\t\t}\n\t\t```\n\nThe test function `TestRegression682831` does not use the data set and therefore\ndoes not call `mustLoadDataset`, which could be slow and failure-prone:\n\n```go\n\t\t// Bad:\n\t\tvar dataset []byte\n\n\t\tfunc TestParseData(t *testing.T) {\n\t\t// As documented above without calling mustLoadDataset directly.\n\t\t}\n\n\t\tfunc TestListContents(t *testing.T) {\n\t\t// As documented above without calling mustLoadDataset directly.\n\t\t}\n\n\t\tfunc TestRegression682831(t *testing.T) {\n\t\tif got, want := guessOS(\"zpc79.example.com\"), \"grhat\"; got != want {\n\t\tt.Errorf(`guessOS(\"zpc79.example.com\") = %q, want %q`, got, want)\n\t\t}\n\t\t}\n\n\t\tfunc init() {\n\t\tdataset = mustLoadDataset()\n\t\t}\n\t\t```\n\nA user may wish to run a function in isolation of the others and should not be\npenalized by these factors:\n\n```shell\n\t\t# No reason for this to perform the expensive initialization.\n\t\t$ go test -run TestRegression682831\n\t\t```\n\n\n\n#### When to use a custom `TestMain` entrypoint\n\nIf **all tests in the package** require common setup and the **setup requires\nteardown**, you can use a [custom testmain entrypoint]. This can happen if the\nresource the test cases require is especially expensive to setup, and the cost\nshould be amortized. Typically you have extracted any unrelated tests from the\ntest suite at that point. It is typically only used for [functional tests].\n\nUsing a custom `TestMain` **should not be your first choice** due the amount of\ncare that should be taken for correct use. Consider first whether the solution\nin the [*amortizing common test setup*] section or an ordinary [test helper] is\nsufficient for your needs.\n\n[custom testmain entrypoint]: https://golang.org/pkg/testing/#hdr-Main\n[functional tests]: https://en.wikipedia.org/wiki/Functional_testing\n[*amortizing common test setup*]: #t-setup-amortization\n[test helper]: #t-common-setup-scope\n\n```go\n\t\t// Good:\n\t\tvar db *sql.DB\n\n\t\tfunc TestInsert(t *testing.T) { /* omitted */ }\n\n\t\tfunc TestSelect(t *testing.T) { /* omitted */ }\n\n\t\tfunc TestUpdate(t *testing.T) { /* omitted */ }\n\n\t\tfunc TestDelete(t *testing.T) { /* omitted */ }\n\n\t\t// runMain sets up the test dependencies and eventually executes the tests.\n\t\t// It is defined as a separate function to enable the setup stages to clearly\n\t\t// defer their teardown steps.\n\t\tfunc runMain(ctx context.Context, m *testing.M) (code int, err error) {\n\t\tctx, cancel := context.WithCancel(ctx)\n\t\tdefer cancel()\n\n\t\td, err := setupDatabase(ctx)\n\t\tif err != nil {\n\t\treturn 0, err\n\t\t}\n\t\tdefer d.Close() // Expressly clean up database.\n\t\tdb = d          // db is defined as a package-level variable.\n\n\t\t// m.Run() executes the regular, user-defined test functions.\n\t\t// Any defer statements that have been made will be run after m.Run()\n\t\t// completes.\n\t\treturn m.Run(), nil\n\t\t}\n\n\t\tfunc TestMain(m *testing.M) {\n\t\tcode, err := runMain(context.Background(), m)\n\t\tif err != nil {\n\t\t// Failure messages should be written to STDERR, which log.Fatal uses.\n\t\tlog.Fatal(err)\n\t\t}\n\t\t// NOTE: defer statements do not run past here due to os.Exit\n\t\t//       terminating the process.\n\t\tos.Exit(code)\n\t\t}\n\t\t```\n\nIdeally a test case is hermetic between invocations of itself and between other\ntest cases.\n\nAt the very least, ensure that individual test cases reset any global state they\nhave modified if they have done so (for instance, if the tests are working with\nan external database).\n\n\n\n#### Amortizing common test setup\n\nUsing a `sync.Once` may be appropriate, though not required, if all of the\nfollowing are true about the common setup:\n\n*   It is expensive.\n*   It only applies to some tests.\n*   It does not require teardown.\n\n```go\n\t\t// Good:\n\t\tvar dataset struct {\n\t\tonce sync.Once\n\t\tdata []byte\n\t\terr  error\n\t\t}\n\n\t\tfunc mustLoadDataset(t *testing.T) []byte {\n\t\tt.Helper()\n\t\tdataset.once.Do(func() {\n\t\tdata, err := os.ReadFile(\"path/to/your/project/testdata/dataset\")\n\t\t// dataset is defined as a package-level variable.\n\t\tdataset.data = data\n\t\tdataset.err = err\n\t\t})\n\t\tif err := dataset.err; err != nil {\n\t\tt.Fatalf(\"Could not load dataset: %v\", err)\n\t\t}\n\t\treturn dataset.data\n\t\t}\n\t\t```\n\nWhen `mustLoadDataset` is used in multiple test functions, its cost is\namortized:\n\n```go\n\t\t// Good:\n\t\tfunc TestParseData(t *testing.T) {\n\t\tdata := mustLoadDataset(t)\n\n\t\t// As documented above.\n\t\t}\n\n\t\tfunc TestListContents(t *testing.T) {\n\t\tdata := mustLoadDataset(t)\n\n\t\t// As documented above.\n\t\t}\n\n\t\tfunc TestRegression682831(t *testing.T) {\n\t\tif got, want := guessOS(\"zpc79.example.com\"), \"grhat\"; got != want {\n\t\tt.Errorf(`guessOS(\"zpc79.example.com\") = %q, want %q`, got, want)\n\t\t}\n\t\t}\n\t\t```\n\nThe reason that common teardown is tricky is there is no uniform place to\nregister cleanup routines. If the setup function (in this case `loadDataset`)\nrelies on a context, `sync.Once` may be problematic. This is because the second\nof two racing calls to the setup function would need to wait for the first call\nto finish before returning. This period of waiting cannot be easily made to\nrespect the context's cancellation.\n\n\n\n## String concatenation\n\nThere are several ways to concatenate strings in Go. Some examples include:\n\n*   The \"+\" operator\n*   `fmt.Sprintf`\n*   `strings.Builder`\n*   `text/template`\n*   `safehtml/template`\n\nThough there is no one-size-fits-all rule for which to choose, the following\nguidance outlines when each method is preferred.\n\n\n\n### Prefer \"+\" for simple cases\n\nPrefer using \"+\" when concatenating few strings. This method is syntactically\nthe simplest and requires no import.\n\n```go\n\t\t// Good:\n\t\tkey := \"projectid: \" + p\n\t\t```\n\n\n\n### Prefer `fmt.Sprintf` when formatting\n\nPrefer using `fmt.Sprintf` when building a complex string with formatting. Using\nmany \"+\" operators may obscure the end result.\n\n```go\n\t\t// Good:\n\t\tstr := fmt.Sprintf(\"%s [%s:%d]-> %s\", src, qos, mtu, dst)\n\t\t```\n\n```go\n\t\t// Bad:\n\t\tbad := src.String() + \" [\" + qos.String() + \":\" + strconv.Itoa(mtu) + \"]-> \" + dst.String()\n\t\t```\n\n**Best Practice:** When the output of the string-building operation is an\n`io.Writer`, don't construct a temporary string with `fmt.Sprintf` just to send\nit to the Writer. Instead, use `fmt.Fprintf` to emit to the Writer directly.\n\nWhen the formatting is even more complex, prefer [`text/template`] or\n[`safehtml/template`] as appropriate.\n\n[`text/template`]: https://pkg.go.dev/text/template\n[`safehtml/template`]: https://pkg.go.dev/github.com/google/safehtml/template\n\n\n\n### Prefer `strings.Builder` for constructing a string piecemeal\n\nPrefer using `strings.Builder` when building a string bit-by-bit.\n`strings.Builder` takes amortized linear time, whereas \"+\" and `fmt.Sprintf`\ntake quadratic time when called sequentially to form a larger string.\n\n```go\n\t\t// Good:\n\t\tb := new(strings.Builder)\n\t\tfor i, d := range digitsOfPi {\n\t\tfmt.Fprintf(b, \"the %d digit of pi is: %d\\n\", i, d)\n\t\t}\n\t\tstr := b.String()\n\t\t```\n\n**Note:** For more discussion, see\n[GoTip #29: Building Strings Efficiently](https://google.github.io/styleguide/go/index.html#gotip).\n\n\n\n### Constant strings\n\nPrefer to use backticks (\\`) when constructing constant, multi-line string\n\t\tliterals.\n\n\t\t```go\n// Good:\nusage := `Usage:\n\n\t\tcustom_tool [args]`\n```\n\n\t\t```go\n// Bad:\nusage := \"\" +\n\"Usage:\\n\" +\n\"\\n\" +\n\"custom_tool [args]\"\n```\n\n\t\t<!--\n\n\t\t-->\n\n\t\t{% endraw %}\n\n\t\t\n\n\t\t## Global state\n\n\t\tLibraries should not force their clients to use APIs that rely on\n\t\t[global state](https://en.wikipedia.org/wiki/Global_variable). They are advised\n\t\tnot to expose APIs or export\n\t\t[package level](https://go.dev/ref/spec#TopLevelDecl) variables that control\n\t\tbehavior for all clients as parts of their API. The rest of the section uses\n\t\t\"global\" and \"package level state\" synonymously.\n\n\t\tInstead, if your functionality maintains state, allow your clients to create and\n\t\tuse instance values.\n\n\t\t**Important:** While this guidance is applicable to all developers, it is most\n\t\tcritical for infrastructure providers who offer libraries, integrations, and\n\t\tservices to other teams.\n\n\t\t```go\n// Good:\n// Package sidecar manages subprocesses that provide features for applications.\npackage sidecar\n\ntype Registry struct { plugins map[string]*Plugin }\n\nfunc New() *Registry { return &Registry{plugins: make(map[string]*Plugin)} }\n\nfunc (r *Registry) Register(name string, p *Plugin) error { ... }\n```\n\n\t\tYour users will instantiate the data they need (a `*sidecar.Registry`) and then\n\t\tpass it as an explicit dependency:\n\n\t\t```go\n// Good:\npackage main\n\nfunc main() {\nsidecars := sidecar.New()\nif err := sidecars.Register(\"Cloud Logger\", cloudlogger.New()); err != nil {\nlog.Exitf(\"could not setup cloud logger: %v\", err)\n}\ncfg := &myapp.Config{Sidecars: sidecars}\nmyapp.Run(context.Background(), cfg)\n}\n```\n\n\t\tThere are different approaches to migrating existing code to support dependency\n\t\tpassing. The main one you will use is passing dependencies as parameters to\n\t\tconstructors, functions, methods, or struct fields on the call chain.\n\n\t\tAPIs that do not support explicit dependency passing become fragile as the\n\t\tnumber of clients increases:\n\n\t\t```go\n// Bad:\npackage sidecar\n\nvar registry = make(map[string]*Plugin)\n\nfunc Register(name string, p *Plugin) error { /* registers plugin in registry */ }\n```\n\n\t\tConsider what happens in the case of tests exercising code that transitively\n\t\trelies on a sidecar for cloud logging.\n\n\t\t```go\n// Bad:\npackage app\n\nimport (\n\"cloudlogger\"\n\"sidecar\"\n\"testing\"\n)\n\nfunc TestEndToEnd(t *testing.T) {\n// The system under test (SUT) relies on a sidecar for a production cloud\n// logger already being registered.\n... // Exercise SUT and check invariants.\n}\n\nfunc TestRegression_NetworkUnavailability(t *testing.T) {\n// We had an outage because of a network partition that rendered the cloud\n// logger inoperative, so we added a regression test to exercise the SUT with\n// a test double that simulates network unavailability with the logger.\nsidecar.Register(\"cloudlogger\", cloudloggertest.UnavailableLogger)\n... // Exercise SUT and check invariants.\n}\n\nfunc TestRegression_InvalidUser(t *testing.T) {\n// The system under test (SUT) relies on a sidecar for a production cloud\n// logger already being registered.\n//\n// Oops. cloudloggertest.UnavailableLogger is still registered from the\n// previous test.\n... // Exercise SUT and check invariants.\n}\n```\n\n\t\tGo tests are executed sequentially by default, so the tests above run as:\n\n\t\t1.  `TestEndToEnd`\n\t\t2.  `TestRegression_NetworkUnavailability`, which overrides the default value of\n\t\tcloudlogger\n\t\t3.  `TestRegression_InvalidUser`, which requires the default value of\n\t\tcloudlogger registered in `package sidecar`\n\n\t\tThis creates an order-dependent test case, which breaks running with test\n\t\tfilters, and prevents tests from running in parallel or being sharded.\n\n\t\tUsing global state poses problems that lack easy answers for you and the API's\n\t\tclients:\n\n\t\t*   What happens if a client needs to use different and separately operating\n\t\tsets of `Plugin`s (for example, to support multiple servers) in the same\n\t\tprocess space?\n\n\t\t*   What happens if a client wants to replace a registered `Plugin` with an\n\t\talternative implementation in a test, like a [test double]?\n\n\t\tWhat happens if a client's tests require hermeticity between instances of a\n\t\t`Plugin`, or between all of the plugins registered?\n\n\t\t*   What happens if multiple clients `Register` a `Plugin` under the same name?\n\t\tWhich one wins, if any?\n\n\t\tHow should errors be [handled](decisions#handle-errors)? If the code panics\n\t\tor calls `log.Fatal`, will that always be\n\t\t[appropriate for all places in which API would be called](decisions#dont-panic)?\n\t\tCan a client verify it doesn't do something bad before doing so?\n\n\t\t*   Are there certain stages in a program's startup phases or lifetime during\n\t\twhich `Register` can be called and when it can't?\n\n\t\tWhat happens if `Register` is called at the wrong time? A client could call\n\t\t`Register` in [`func init`](https://go.dev/ref/spec#Package_initialization),\n\t\tbefore flags are parsed, or after `main`. The stage at which a function is\n\t\tcalled affects error handling. If the author of an API assumes the API is\n\t\t*only* called during program initialization without the requirement that it\n\t\tis, the assumption may nudge the author to design error handling to\n\t\t[abort the program](best-practices#program-init) by modeling the API as a\n\t\t`Must`-like function. Aborting is not appropriate for general-purpose\n\t\tlibrary functions that can be used at any stage.\n\n\t\t*   What if the client's and the designer's concurrency needs are mismatched?\n\n\t\t### Major forms of package state APIs\n\n\t\tSeveral of the most common problematic API forms are enumerated below:\n\n\t\t*   Top-level variables irrespective of whether they are exported.\n\n\t\t```go\n    // Bad:\n    package logger\n\n    // Sinks manages the default output sources for this package's logging API.  This\n    // variable should be set at package initialization time and never thereafter.\n    var Sinks []Sink\n    ```\n\n\t\tSee the [litmus tests](#globals-litmus-tests) to know when these are safe.\n\n\t\t*   The\n\t\t[service locator pattern](https://en.wikipedia.org/wiki/Service_locator_pattern).\n\t\tSee the [first example](#globals). The service locator pattern itself is not\n\t\tproblematic, rather the locator being defined as global.\n\n\t\t*   Registries for\n\t\t[callbacks](https://en.wikipedia.org/wiki/Callback_\\(computer_programming\\))\n\t\tand similar behaviors.\n\n\t\t```go\n    // Bad:\n    package health\n\n    var unhealthyFuncs []func\n\n    func OnUnhealthy(f func()) {\n      unhealthyFuncs = append(unhealthyFuncs, f)\n    }\n    ```\n\n\t\t*   Thick-Client singletons for things like backends, storage, data access\n\t\tlayers, and other system resources. These often pose additional problems\n\t\twith service reliability.\n\n\t\t```go\n    // Bad:\n    package useradmin\n\n    var client pb.UserAdminServiceClientInterface\n\n    func Client() *pb.UserAdminServiceClient {\n        if client == nil {\n            client = ...  // Set up client.\n        }\n        return client\n    }\n    ```\n\n\t\t> **Note:** Many legacy APIs in the Google codebase do not follow this guidance;\n\t\t> in fact, some Go standard libraries allow for configuration via global values.\n\t\t> Nevertheless, the legacy API's contravention of this guidance\n\t\t> **[should not be used as precedent](guide#local-consistency)** for continuing\n\t\t> the pattern.\n\t\t>\n\t\t> It is better to invest in proper API design today than pay for redesigning\n\t\t> later.\n\n\t\t\n\n\t\t### Litmus tests\n\n\t\t[APIs using the patterns above](#globals-forms) are unsafe when:\n\n\t\t*   Multiple functions interact via global state when executed in the same\n\t\tprogram, despite being otherwise independent (for example, authored by\n\t\tdifferent authors in vastly different directories).\n\t\t*   Independent test cases interact with each other through global state.\n\t\t*   Users of the API are tempted to swap or replace global state for testing\n\t\tpurposes, particularly to replace any part of the state with a\n\t\t[test double], like a stub, fake, spy, or mock.\n\t\t*   Users have to consider special ordering requirements when interacting with\n\t\tglobal state: `func init`, whether flags are parsed yet, etc.\n\n\t\tProvided the conditions above are avoided, there are a **few limited\n\t\tcircumstances under which these APIs are safe**, namely when any of the\n\t\tfollowing is true:\n\n\t\t*   The global state is logically constant\n\t\t([example](https://github.com/klauspost/compress/blob/290f4cfacb3eff892555a491e3eeb569a48665e7/zstd/snappy.go#L413)).\n\t\t*   The package's observable behavior is stateless. For example, a public\n\t\tfunction may use a private global variable as a cache, but so long as the\n\t\tcaller can't distinguish cache hits from misses, the function is stateless.\n\t\t*   The global state does not bleed into things that are external to the\n\t\tprogram, like sidecar processes or files on a shared filesystem.\n\t\t*   There is no expectation of predictable behavior\n\t\t([example](https://pkg.go.dev/math/rand)).\n\n\t\t> **Note:**\n\t\t> [Sidecar processes](https://www.oreilly.com/library/view/designing-distributed-systems/9781491983638/ch02.html)\n\t\t> may **not** strictly be process-local. They can and often are shared with more\n\t\t> than one application process. Moreover, these sidecars often interact with\n\t\t> external distributed systems.\n\t\t>\n\t\t> Further, the same stateless, idempotent, and local rules in addition to the\n\t\t> base considerations above would apply to the code of the sidecar process\n\t\t> itself!\n\n\t\tAn example of one of these safe situations is\n\t\t[`package image`](https://pkg.go.dev/image) with its\n\t\t[`image.RegisterFormat`](https://pkg.go.dev/image#RegisterFormat) function.\n\t\tConsider the litmus tests from above applied to a typical decoder, like the one\n\t\tfor handling the [PNG](https://pkg.go.dev/image/png) format:\n\n\t\t*   Multiple calls to `package image`'s APIs that use the registered decoders\n\t\t(for example, `image.Decode`) cannot interfere with one another, similarly\n\t\tfor tests. The only exception is `image.RegisterFormat`, but that is\n\t\tmitigated by the points below.\n\t\t*   It is extremely unlikely that a user would want to replace a decoder with a\n\t\t[test double], as the PNG decoder exemplifies a case in which our codebase's\n\t\tpreference for real objects applies. However, a user would be more likely to\n\t\treplace a decoder with a test double if the decoder statefully interacted\n\t\twith operating system resources (for example, the network).\n\t\t*   Collisions in registration are conceivable, though they are probably rare in\n\t\tpractice.\n\t\t*   The decoders are stateless, idempotent, and pure.\n\n\t\t\n\n\t\t### Providing a default instance\n\n\t\tWhile not recommended, it is acceptable to provide a simplified API that uses\n\t\tpackage level state if you need to maximize convenience for the user.\n\n\t\tFollow the [litmus tests](#globals-litmus-tests) with these guidelines in such\n\t\tcases:\n\n\t\t1.  The package must offer clients the ability to create isolated instances of\n\t\tpackage types as [described above](#globals-forms).\n\t\t2.  The public APIs that use global state must be a thin proxy to the previous\n\t\tAPI. A good example of this is\n\t\t[`http.Handle`](https://pkg.go.dev/net/http#Handle) internally calling\n\t\t[`(*http.ServeMux).Handle`](https://pkg.go.dev/net/http#ServeMux.Handle) on\n\t\tthe package variable\n\t\t[`http.DefaultServeMux`](https://pkg.go.dev/net/http#DefaultServeMux).\n\t\t3.  This package-level API must only be used by [binary build targets], not\n\t\t[libraries], unless the libraries are undertaking a refactoring to support\n\t\tdependency passing. Infrastructure libraries that can be imported by other\n\t\tpackages must not rely on package-level state of the packages they import.\n\n\t\tFor example, an infrastructure provider implementing a sidecar that is to be\n\t\tshared with other teams using the API from the top should offer an API to\n\t\taccommodate this:\n\n\t\t```go\n    // Good:\n    package cloudlogger\n\n    func New() *Logger { ... }\n\n    func Register(r *sidecar.Registry, l *Logger) {\n      r.Register(\"Cloud Logging\", l)\n    }\n    ```\n\n\t\t4.  This package-level API must [document](#documentation-conventions) and\n\t\tenforce its invariants (for example, at which stage in the program's life it\n\t\tcan be called, whether it can be used concurrently). Further, it must\n\t\tprovide an API to reset global state to a known-good default (for example,\n\t\tto facilitate testing).\n"
}
